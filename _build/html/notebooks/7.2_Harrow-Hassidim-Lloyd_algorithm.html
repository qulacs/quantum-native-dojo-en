

<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
      <meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="docsearch:name" content="Quantum Native Dojo" />
    <meta name="docsearch:package_type" content="" />
    <meta name="docsearch:release" content="" />
    <meta name="docsearch:version" content="" />
    
      <title>7-2. Harrow-Hassidim-Lloyd (HHL) Algorithm &mdash; Quantum Native Dojo  documentation</title>
    
    <link rel="stylesheet" href="../_static/bootstrap-icons.css" type="text/css" />
          <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=e7352e39" />
          <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=e15ddae3" />
          <link rel="stylesheet" type="text/css" href="../_static/colorsets/sphinx-nefertiti-blue.min.css" />
          <link rel="stylesheet" type="text/css" href="../_static/fonts/nunito/stylesheet.css" />
          <link rel="stylesheet" type="text/css" href="../_static/fonts/red-hat-mono/stylesheet.css" />
          <link rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=e15ddae3" />
        <link rel="index" title="Index" href="../genindex.html" />
        <link rel="search" title="Search" href="../search.html" />
        <link rel="top" title="Quantum Native Dojo  documentation" href="#" />
        <link rel="up" title="chapter 7 Quantum phase estimation algorithm and its application" href="7_quantum_phase_estimation.html" />
        <link rel="next" title="7-3. Portfolio optimization using HHL algorithm" href="7.3_application_of_HHL_algorithm.html" />
        <link rel="prev" title="7-1. Quantum Phase Estimation Algorithm in Detail: Application to Hydrogen Molecule as an Example" href="7.1_quantum_phase_estimation_detailed.html" />
    <style>
      :root {
        --nftt-body-font-family: "Nunito", var(--nftt-font-sans-serif) !important;
        --nftt-font-monospace: "Red Hat Mono", var(--nftt-font-family-monospace) !important;
        --nftt-project-name-font: var(--nftt-body-font-family);
        --nftt-documentation-font: var(--nftt-body-font-family);
        --nftt-doc-headers-font: "Georgia", var(--nftt-documentation-font);}
      h1 *, h2 *, h3 *, h4 *, h5 *, h6 * { font-size: inherit; }
    </style>
  </head>
  <body>
    <header class="navbar navbar-expand-xl navbar-dark nftt-navbar flex-column fixed-top">
      <div class="skip-links container-fluid visually-hidden-focusable overflow-hidden justify-content-start">
        <div class="border-bottom mb-2 pb-2 w-100">
          <a class="d-none d-md-inline-flex p-2 m-1" href="#sidebar-filter">Skip to docs navigation</a>
          <a class="d-inline-flex p-2 m-1" href="#content">Skip to main content</a>
        </div>
      </div>
      <nav class="container-xxl nftt-gutter flex-wrap flex-xl-nowrap" aria-label="Main navigation">
        <div class="nftt-navbar-toggler">
          <button class="navbar-toggler p-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#sidebar" aria-controls="sidebar" aria-label="Toggle documentation navigation">
            <i class="bi bi-list"></i>
          </button>
        </div>
          <a href="../index.html"
              
              class="navbar-brand p-0 me-0 md-lg-2"
          ><span class="brand-text">Quantum Native Dojo</span></a>
        
        <div class="d-flex d-xl-none">
          <button class="navbar-toggler p-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#nfttSearch" aria-controls="nfttSearch" aria-label="Search">
            <i class="bi bi-search"></i>
          </button>
          <button class="navbar-toggler p-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#nfttNavbar" aria-controls="nfttNavbar" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
        </div>
        
<div class="offcanvas-xl offcanvas-end flex-grow-1" tabindex="-1" id="nfttSearch" aria-labelledby="nfttSearchOffcanvasLabel" data-bs-scroll="true">
  <div class="offcanvas-header px-4 pb-0">
    <h5 class="offcanvas-title fw-bold" id="nfttSearchOffcanvasLabel">Search the documentation</h5>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close" data-bs-target="#nfttSearch"></button>
  </div>
  <div class="offcanvas-body p-4 pt-0 p-xl-0 px-xl-3">
    <hr class="d-xl-none text-white-50">
    <ul class="navbar-nav flex-row align-items-center flex-wrap ms-md-auto">
      <li class="nav-item col-12 col-xl-auto">
        <form id="nftt-search-form" action="../search.html" method="get">
          <div class="input-group">
            <input type="text" name="q" class="form-control" placeholder="Search docs" aria-label="Search" aria-describedby="button-search">
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
            <button class="btn btn-primary" type="submit" id="button-search" aria-label="Search"><i class="bi bi-search"></i></button>
          </div>
        </form>
      </li>
    </ul>
  </div>
</div>

        <div class="offcanvas-xl offcanvas-end" tabindex="-1" id="nfttNavbar" aria-labelledby="nfttNavbarOffcanvasLabel" data-bs-scroll="true">
          <div class="offcanvas-header px-4 pb-0">
            <div class="offcanvas-title navbar-brand" id="nfttNavbarOffcanvasLabel"><span class="brand-text">Nefertiti for Sphinx</span></div>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close" data-bs-target="#nfttNavbar"></button>
          </div>
          <div class="offcanvas-body p-4 pt-0 p-xl-0 px-xl-3">
            <hr class="d-xl-none text-white-50">
            <ul class="navbar-nav flex-row align-items-center flex-wrap ms-lg-auto">
              
              <!-- version_dropdown.html -->

              
              <!-- colorscheme_dropdown.html -->
<li class="nav-item dropdown">
  <a class="nav-link d-flex py-2 px-0 px-xl-2 dropdown-toggle align-items-center" id="snftt-luz" href="#" data-bs-toggle="dropdown" data-bs-display="static" aria-expanded="false" aria-label="Toggle light/dark">
    <i class="bi bi-circle-half" data-snftt-luz-icon-active></i>
    <span id="snftt-luz-text" class="d-xl-none small ms-2">Toggle light/dark</span>
  </a>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="snftt-luz-text">
    <li>
      <h6 class="dropdown-header">Light/dark</h6>
    </li>
    <li>
      <a class="dropdown-item d-flex align-items-center" data-snftt-luz="light" href="#" aria-pressed="false">
        <span class="small">
          <i class="bi bi-sun" data-snftt-luz-icon="light"></i>
        </span>
        <span class="small ms-3">Light</span>
        <i class="bi bi-check ms-auto"></i>
      </a>
    </li>
    <li>
      <a class="dropdown-item d-flex align-items-center" data-snftt-luz="dark" href="#" aria-pressed="false">
        <span class="small">
          <i class="bi bi-moon-stars" data-snftt-luz-icon="dark"></i>
        </span>
        <span class="small ms-3">Dark</span>
        <i class="bi bi-check ms-auto"></i>
      </a>
    </li>
    <li>
      <a class="dropdown-item current d-flex align-items-center" data-snftt-luz="default" href="#" aria-pressed="false">
        <span class="small">
          <i class="bi bi-circle-half" data-snftt-luz-icon="default"></i>
        </span>
        <span class="small ms-3">Default</span>
        <i class="bi bi-check ms-auto"></i>
      </a>
    </li>
  </ul>
</li>
            </ul>
          </div>
        </div>
      </nav>
    </header>

    <div class="container-fluid">
      <div class="nftt-gutter nftt-page">
        <aside class="nftt-sidebar">
          <div class="nftt-sidebar-content">
            <div class="title d-none d-xl-block">
              <i class="bi bi-book"></i>&nbsp;&nbsp;<span>Index</span>
            </div>
            <div id="sidebar" tabindex="-1" class="offcanvas-xl offcanvas-start" aria-labelledby="nfttSidebarOffcanvasLabel">
                <!-- danirus sidebartemplate: "globaltoc.html" --><div class="offcanvas-header border-bottom">
  <h5 class="offcanvas-title fw-bold" id="nfttSidebarOffcanvasLabel">
    Table of contents
  </h5>
  <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close" data-bs-target="#sidebar"></button>
</div>

<div class="offcanvas-body">
  <nav class="toc" aria-label="Main menu">
    <div class="mb-3 p-1 pt-3 pb-4 border-bottom">
      <input id="sidebar-filter" type="text" name="filter" class="form-control form-control-sm" placeholder="filter" aria-label="filter">
    </div>
    <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0_prologue.html">Chapter 0: What is a Quantum Computer ?</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_quantum_information_foundation.html">Chapter 1: Fundamentals of Quantum Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="1.1_qubit_representation.html">1-1. Qubit Representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.2_qubit_operations.html">1-2. Qubit Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.3_multiqubit_representation_and_operations.html">1-3. Multiqubit representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.3_multiqubit_representation_and_operations.html#Column:-What-is-a-universal-gate-set?">Column: What is a universal gate set?</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.4_quantum_circuit_diagram.html">1-4. Quantum Circuit Diagram</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="2_introduction_to_quantum_algorithms.html">Chapter 2: Introduction to Quantum Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="2.1_NISQ_and_long_term.html">2-1. NISQ algorithm and long-term algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.2_Hadamard_test.html">2-2. Hadamard test</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.3_quantum_Fourier_transform.html">2-3. Quantum Fourier transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.4_phase_estimation_beginner.html">2-4. Phase Estimation Algorithm（Introductory）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="3_execution_environments_of_quantum_algorithms.html">Chapter 3: Execution Environment for Quantum Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="3.1_Qulacs_tutorial.html">3-1. Qulacs_tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.2_Qiskit_IBMQ.html">3-2. Qiskit_IBMQ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="4_quantum_dynamics_simulation.html">Chapter4 Quantum dynamics simulation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="4.1_quantum_simulation.html">4-1. Quantum Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.2_trotter_decomposition.html">4-2. Trotter Decomposition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="5_VQC_based_algorithms.html">Chapter 5 Algorithms Based on Variational Quantum Circuits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="5.1_variational_quantum_eigensolver.html">5-1. Variational Quantum Eigensolver（VQE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.2_Quantum_Circuit_Learning.html">5-2. Quantum Circuit Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.3_quantum_approximate_optimazation_algorithm.html">5-3. Quantum Approximate Optimazation Algorithm (QAOA)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="6_quantum_chemistry_calculation.html">Chapter 6 Quantum chemistry calculation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="6.1_openfermion_basics.html">6-1. OpenFermion Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.2_qp_VQE.html">6-2. Variational Quantum Eigensolver (VQE) Implementation using QURI Parts</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.3_subspace_search_VQE.html">6-3. Calculation of Excited States using Subspace-Search Variational Quantum Eigensolver</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="7_quantum_phase_estimation.html">chapter 7 Quantum phase estimation algorithm and its application</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="7.1_quantum_phase_estimation_detailed.html">7-1. Quantum Phase Estimation (QPE) Algorithm Detailed：Hydrogen Molecule as Example</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">7-2. Harrow-Hassidim-Lloyd (HHL) Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.3_application_of_HHL_algorithm.html">7-3. Portofolio Optimization by HHL Algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="8_quantum_search_algorithm.html">Chapter 8: Quantum Search Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="8.1_oracle.html">8-1. oracle</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.2_Grovers_algorithm.html">8-2. Grover’s algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="9_quantum_error_correction.html">Chapter 9 Quantum Error Correction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="9.1_error_correction.html">9-1. classical error</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.2_quantum_error_correction.html">9-2. quantum error</a></li>
</ul>
</li>
</ul>

  </nav>
  <template data-toggle-item-template>
    <button class="btn btn-sm btn-link toctree-expand" type="button">
      <i class="bi bi-caret-right"></i>
      <span class="visually-hidden">Toggle menu contents</span>
    </button>
  </template>
</div>
            </div>
          </div>
        </aside>
        <article id="content" class="nftt-content" role="main">
    <section id="7-2.-Harrow-Hassidim-Lloyd-(HHL)-Algorithm">
<h1>7-2. Harrow-Hassidim-Lloyd (HHL) Algorithm<a class="headerlink" href="#7-2.-Harrow-Hassidim-Lloyd-(HHL)-Algorithm" title="Link to this heading">¶</a></h1>
<p>In this section, we introduce the Harrow-Hassidim-Lloyd (HHL) algorithm, one of the most important applications of the quantum phase estimation algorithm, which is a fast “solving” algorithm for (sparse) simultaneous linear equations. It has attracted a great deal of attention because simultaneous linear equations are used in all kinds of scientific and engineering calculations, including electromagnetic, thermal, and fluid analysis, machine learning, and so on. The content of this section is
based on the original paper [1] and the review paper [2].</p>
<section id="Problem-Setup">
<h2>Problem Setup<a class="headerlink" href="#Problem-Setup" title="Link to this heading">¶</a></h2>
<p>The HHL algorithm efficiently “computes” the solution <span class="math notranslate nohighlight">\(\mathbf{x}=A^{-1}\mathbf{b}\)</span>　of the linear system <span class="math notranslate nohighlight">\(A\mathbf{x}=\mathbf{b}\)</span> for a sparse, regular <span class="math notranslate nohighlight">\(N \times N\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span> and an <span class="math notranslate nohighlight">\(N\)</span>-dimensional vector <span class="math notranslate nohighlight">\(\bf{b}\)</span>. (In this section, vectors are denoted by <strong>bold</strong>):.</p>
<div class="math notranslate nohighlight">
\[|\mathbf{b} \rangle \xrightarrow{\text{HHL}} | A^{-1}\mathbf{b} \rangle.\]</div>
<p>Let me explain what this equation means. First, the state <span class="math notranslate nohighlight">\(|\mathbf{x}\rangle, |\mathbf{b}\rangle\)</span> with a vector in the ket is defined as follows:.</p>
<div class="math notranslate nohighlight">
\[|\mathbf{x}\rangle = \frac{\sum_i x_i |i \rangle}{\sqrt{\sum_i |x_i|^2}},  |\mathbf{b}\rangle = \frac{\sum_i b_i |i \rangle}{\sqrt{\sum_i |b_i|^2}},\]</div>
<p>where <span class="math notranslate nohighlight">\(x_i, b_i\)</span> are the <span class="math notranslate nohighlight">\(i=0,1,\ldots, N-1\)</span>-th component of the vector and <span class="math notranslate nohighlight">\(|i\rangle\)</span> is the computational basis corresponding to the binary representation of <span class="math notranslate nohighlight">\(i\)</span> (for example, <span class="math notranslate nohighlight">\(|5\rangle = |0\cdots0101\rangle\)</span>). To represent a vector of <span class="math notranslate nohighlight">\(N\)</span> components, we only need <span class="math notranslate nohighlight">\(\log_2 N\)</span> qubits. The HHL algorithm is an algorithm that uses the quantum phase estimation algorithm and auxiliary bits to quickly and accurately create a solution state
<span class="math notranslate nohighlight">\(|A^{-1}\mathbf{b}\rangle\)</span> from the input state <span class="math notranslate nohighlight">\(|\mathbf{b}\rangle\)</span>.</p>
<p>A detailed description of the computational complexity is given at the end of this section, but the HHL algorithm can perform the above transformation with a computational complexity of <span class="math notranslate nohighlight">\(O(\text{poly}(\log N))\)</span>, or about <span class="math notranslate nohighlight">\(\log N\)</span> polynomials. The computational complexity of the current best classical algorithm for a similar calculation is <span class="math notranslate nohighlight">\(O(N)\)</span>, so the HHL algorithm achieves exponential acceleration. However, there are some important <strong>cautions</strong>:.</p>
<ul class="simple">
<li><p>The matrix <span class="math notranslate nohighlight">\(A\)</span> must be SPARSE. Specifically, the number of nonzero components in each row must be <span class="math notranslate nohighlight">\(O(\text{poly}(\log N))\)</span>.</p></li>
<li><p>From the given classical data <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, it is not easy in general to prepare the state <span class="math notranslate nohighlight">\(|\mathbf{b}\rangle\)</span> on a quantum computer, and input could cost <span class="math notranslate nohighlight">\(O(N)\)</span> of computation. The above <span class="math notranslate nohighlight">\(O(\text{poly}(\log N))\)</span> is based on the assumption that the state <span class="math notranslate nohighlight">\(|\mathbf{b}\rangle\)</span> is available. In <a class="reference external" href="7.2c_quantum_random_access_memory.ipynb">Column: Quantum Random Access Memory (qRAM)</a>, this point is explained in a little more depth.</p></li>
<li><p>Reading out the output solution state <span class="math notranslate nohighlight">\(| A^{-1}\mathbf{b} \rangle\)</span> as the classical vector <span class="math notranslate nohighlight">\(A^{-1}\mathbf{b}\)</span> also takes <span class="math notranslate nohighlight">\(O(N)\)</span> of time, and the exponential acceleration is offset.</p></li>
</ul>
</section>
<section id="Algorithm-Flow">
<h2>Algorithm Flow<a class="headerlink" href="#Algorithm-Flow" title="Link to this heading">¶</a></h2>
<p>Let us take the simplest version as an example and explain the flow of the HHL algorithm. The overall schematic is as follows [2]. <img alt="Quantum circuit of the HHL algorithm" src="../_images/HHL_schematic_diagram.png" /></p>
<p>In the following, for simplicity, we assume that <span class="math notranslate nohighlight">\(A\)</span> is a Hermitian matrix. If A$ is not Hermitian, we can set it as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tilde{A} =
\left(
\begin{array}{ll}
O &amp; A \\
A^\dagger &amp; O
\end{array}
\right),
\tilde{\mathbf{b}} =
\left(
\begin{array}{ll}
\mathbf{b}  \\
\mathbf{0}
\end{array}
\right)\end{split}\]</div>
<p>and use the solution <span class="math notranslate nohighlight">\(\tilde{\mathbf{x}} = (\mathbf{0}, \mathbf{x})^T\)</span>. Also, multiply <span class="math notranslate nohighlight">\(A\)</span> by an appropriate constant so that the difference between the maximum and minimum eigenvalues of <span class="math notranslate nohighlight">\(A\)</span> is less than <span class="math notranslate nohighlight">\(2\pi\)</span> (to ensure a one-to-one correspondence between eigenvalues and bit strings when using the quantum phase estimation algorithm). And also find the constant shift <span class="math notranslate nohighlight">\(d\)</span> such that all eigenvalues fall within <span class="math notranslate nohighlight">\([0, 2\pi]\)</span> when the eigenvalues of the constant
multiplied <span class="math notranslate nohighlight">\(A\)</span> are shifted by d (details will be described later; for now, let <span class="math notranslate nohighlight">\(d=0\)</span> be used).</p>
<section id="1.-prepare-the-input-state-|\mathbf{b}\rangle.">
<h3>1. prepare the input state <span class="math notranslate nohighlight">\(|\mathbf{b}\rangle\)</span>.<a class="headerlink" href="#1.-prepare-the-input-state-|\mathbf{b}\rangle." title="Link to this heading">¶</a></h3>
<p>As mentioned earlier, we prepare a state <span class="math notranslate nohighlight">\(|\mathbf{b}\rangle\)</span> on the quantum computer from the given classical data (vector) <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> using qRAM and so on. Since we will be using multiple auxiliary bits, the qubits used for the input state will have a subscript <span class="math notranslate nohighlight">\(I\)</span> and be denoted as <span class="math notranslate nohighlight">\(|\mathbf{b}\rangle_I\)</span>.</p>
</section>
<section id="2.-Store-eigenvalues-of-A-in-auxiliary-clock-bits-using-the-phase-estimation-algorithm-with-unitary-operation-e^{i-A-}.">
<h3>2. Store eigenvalues of <span class="math notranslate nohighlight">\(A\)</span> in auxiliary clock bits using the phase estimation algorithm with unitary operation <span class="math notranslate nohighlight">\(e^{i A }\)</span>.<a class="headerlink" href="#2.-Store-eigenvalues-of-A-in-auxiliary-clock-bits-using-the-phase-estimation-algorithm-with-unitary-operation-e^{i-A-}." title="Link to this heading">¶</a></h3>
<p>Prepare <span class="math notranslate nohighlight">\(n\)</span> quantum bits of auxiliary clock (C) bits for the phase estimation algorithm.</p>
<div class="math notranslate nohighlight">
\[|\mathbf{b} \rangle_I \to |\mathbf{b} \rangle_I |0\cdots0\rangle_C.\]</div>
<p>Then, execute the quantum phase estimation algorithm for the unitary operation <span class="math notranslate nohighlight">\(E^{iA}\)</span> and the eigenvalues <span class="math notranslate nohighlight">\(\{ \lambda_i \}_{i=0}^{N-1}\)</span> of <span class="math notranslate nohighlight">\(A\)</span> are stored in the auxiliary clock bit. Specifically, we expand the classical vector <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> by the eigenvector <span class="math notranslate nohighlight">\(\{\mathbf{u}_i \}_{i=0}^{N-1}\)</span> of <span class="math notranslate nohighlight">\(A\)</span> and</p>
<div class="math notranslate nohighlight">
\[\mathbf{b} = \sum_i \beta_i \mathbf{u}_i\]</div>
<p>when the above formula holds, in the sense of quantum states</p>
<div class="math notranslate nohighlight">
\[|\mathbf{b}\rangle = \sum_i \beta_i |\mathbf{u}_i\rangle\]</div>
<p>holds. Therefore, by the quantum phase estimation algorithm,</p>
<div class="math notranslate nohighlight">
\[|\mathbf{b} \rangle_I |0\cdots0\rangle_C = \sum_i \beta_i  |\mathbf{u}_i\rangle_I |0\cdots0\rangle_C
\xrightarrow{\text{QPE}} \sum_i \beta_i  |\mathbf{u}_i\rangle_I |\tilde{\lambda}_i \rangle_C\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{\lambda}\)</span> is the bit sequence <span class="math notranslate nohighlight">\(j_1\ldots j_n\)</span> of <span class="math notranslate nohighlight">\(\lambda = 2\pi 0.j_1 \ldots j_n\)</span> obtained by displaying <span class="math notranslate nohighlight">\(\lambda\)</span> in binary.</p>
</section>
<section id="3.-Multiply-the-inverse-of-the-eigenvalues-by-a-control-rotation-using-auxiliary-clock-bits">
<h3>3. Multiply the inverse of the eigenvalues by a control rotation using auxiliary clock bits<a class="headerlink" href="#3.-Multiply-the-inverse-of-the-eigenvalues-by-a-control-rotation-using-auxiliary-clock-bits" title="Link to this heading">¶</a></h3>
<p>Let’s add one more auxiliary bit and represent it with subscript <span class="math notranslate nohighlight">\(S\)</span>.</p>
<div class="math notranslate nohighlight">
\[\sum_i \beta_i  |\mathbf{u}_i\rangle_I |\tilde{\lambda}_i \rangle_C \to \sum_i \beta_i  |\mathbf{u}_i\rangle_I |\tilde{\lambda}_i \rangle_C |0\rangle_S\]</div>
<p>Here, the following controlled rotation gate with auxiliary clock bits is acted upon.</p>
<div class="math notranslate nohighlight">
\[|\tilde{\lambda} \rangle_C |0\rangle_S \to |\tilde{\lambda} \rangle_C \left( \sqrt{1 - \frac{c^2}{\lambda^2}} |0\rangle_S + \frac{c}{\lambda} |1\rangle_S\right)\]</div>
<p>In other words, depending on the value <span class="math notranslate nohighlight">\(\tilde{\lambda}\)</span> of the auxiliary clock bit, a gate that performs a Y-rotation <span class="math notranslate nohighlight">\(R_Y(\theta)=e^{i\ theta/2Y}\)</span> of the rotation angle <span class="math notranslate nohighlight">\(\theta = 2\arctan{( - c/(\lambda \sqrt{1-c^2/{\lambda}^{2} }))}\)</span> acts on the auxiliary bit <span class="math notranslate nohighlight">\(S\)</span>. <span class="math notranslate nohighlight">\(c\)</span> is a normalization constant introduced to allow such a controlled rotation gate and should be kept smaller than the minimum possible <span class="math notranslate nohighlight">\(|\lambda|\)</span>: <span class="math notranslate nohighlight">\(|c| \leq \max |\lambda|\)</span>. Note that
when the first defined constant shift <span class="math notranslate nohighlight">\(d\)</span> is nonzero, it should be replaced by <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\lambda + d\)</span>.</p>
<p>The construction of this controlled rotation gate is rather technical, so interested readers are encouraged to read the note below, but it should be remarked that quite a lot of auxiliary bits are required.</p>
<section id="Note:-How-to-construct-a-controlled-rotation-gate">
<h4>Note: How to construct a controlled rotation gate<a class="headerlink" href="#Note:-How-to-construct-a-controlled-rotation-gate" title="Link to this heading">¶</a></h4>
<p>Since quantum circuits encompass classical circuits, in principle they can perform any operation that can be performed by classical circuits. Therefore, it is possible to construct a gate <span class="math notranslate nohighlight">\(|\lambda \rangle \to |2\arctan( - c/(\lambda \sqrt{1- c^2/\lambda^2}))\rangle\)</span> that superimposes the classical operation <span class="math notranslate nohighlight">\(|\lambda \rangle \to 2\arctan( - c/(\lambda \sqrt{1-c^2/\lambda^2}))\)</span> to calculate the angle of rotation. However, one or more auxiliary bits are required for each irreversible
gate such as NAND in a classical circuit, and a significant number of auxiliary bits are needed just to perform this arithmetic. And since the control rotation gate <span class="math notranslate nohighlight">\(|\theta\rangle |0\rangle_S \to |\theta\rangle R_Y(\theta) |0\rangle_S\)</span> according to the value of <span class="math notranslate nohighlight">\(\theta\)</span> can be implemented by using a simple control <span class="math notranslate nohighlight">\(R_Y\)</span> gate <span class="math notranslate nohighlight">\(\Lambda(R_Y)\)</span> like the quantum phase estimation algorithm, a control rotation gate with the desired auxiliary clock bit can also be implemented.</p>
</section>
</section>
<section id="4.-Inverse-operation-of-quantum-phase-estimation-to-restore-the-auxiliary-clock-bits">
<h3>4. Inverse operation of quantum phase estimation to restore the auxiliary clock bits<a class="headerlink" href="#4.-Inverse-operation-of-quantum-phase-estimation-to-restore-the-auxiliary-clock-bits" title="Link to this heading">¶</a></h3>
<p>With control rotation, the overall state is as follows.</p>
<div class="math notranslate nohighlight">
\[\sum_i \beta_i  |\mathbf{u}_i\rangle_I |\tilde{\lambda}_i \rangle_C \left( \sqrt{1 - \frac{c^2}{\lambda_i^2}} |0\rangle_S + \frac{c}{\lambda_i} |1\rangle_S\right)\]</div>
<p>Applying the inverse operation of the quantum phase estimation algorithm here, we obtain</p>
<div class="math notranslate nohighlight">
\[\sum_i \beta_i  |\mathbf{u}_i\rangle_I |0\cdots 0\rangle_C \left( \sqrt{1 - \frac{c^2}{\lambda_i^2}} |0\rangle_S + \frac{c}{\lambda_i} |1\rangle_S\right)\]</div>
</section>
<section id="5.-Measure-auxiliary-bit-S.">
<h3>5. Measure auxiliary bit <span class="math notranslate nohighlight">\(S\)</span>.<a class="headerlink" href="#5.-Measure-auxiliary-bit-S." title="Link to this heading">¶</a></h3>
<p>Finally, measure the auxiliary bit <span class="math notranslate nohighlight">\(S\)</span>. If <code class="docutils literal notranslate"><span class="pre">1</span></code> is obtained, the state is</p>
<div class="math notranslate nohighlight">
\[\propto \sum_i \beta_i \cdot \frac{c}{\lambda_i}  |\mathbf{u}_i\rangle_I |0\cdots 0\rangle_C\]</div>
<p>If we also projectively measure the auxiliary clock bits to <span class="math notranslate nohighlight">\(|0\cdots0\rangle\)</span>, we get state</p>
<div class="math notranslate nohighlight">
\[\propto \sum_i \beta_i \cdot \frac{c}{\lambda_i}  |\mathbf{u}_i\rangle_I\]</div>
<p>Actually, this is <span class="math notranslate nohighlight">\(| A^{-1}\mathbf{b} \rangle\)</span>!</p>
<p><span class="math notranslate nohighlight">\(\because\)</span> Since the eigenvalues and eigenvectors of <span class="math notranslate nohighlight">\(A\)</span> are <span class="math notranslate nohighlight">\(\lambda_i, \mathbf{u}_i\)</span>, eigenvalue decomposition yields　<span class="math notranslate nohighlight">\(A = \sum_i \lambda_i \mathbf{u}_i {\mathbf{u}_i}^{\dagger}\)</span> (<span class="math notranslate nohighlight">\(\dagger\)</span> is the transpose conjugate). Thus <span class="math notranslate nohighlight">\(A^{-1} = \sum_i (\lambda_i)^{-1} \mathbf{u}_i {\mathbf{u}_i}^{\dagger}\)</span> and <span class="math notranslate nohighlight">\(A^{-1}\mathbf{b} = \sum_i \beta_i (\lambda_i)^{-1} \mathbf{u}_i\)</span> . If we adjust the normalization factor appropriately, we can see that the above state
is <span class="math notranslate nohighlight">\(| A^{-1}\mathbf{b} \rangle\)</span>.</p>
</section>
</section>
<section id="About-the-computational-complexity">
<h2>About the computational complexity<a class="headerlink" href="#About-the-computational-complexity" title="Link to this heading">¶</a></h2>
<p>The above is the flow of the HHL algorithm. Finally, we mention the computational complexity.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(s\)</span> is the sparsity of <span class="math notranslate nohighlight">\(A\)</span>, i.e., the maximum number of non-zero elements in each row.</p></li>
<li><p><span class="math notranslate nohighlight">\(\kappa\)</span> is the condition number of <span class="math notranslate nohighlight">\(A\)</span>: <span class="math notranslate nohighlight">\(\kappa = |\lambda|_{\textrm{max}} / |\lambda|_{\textrm{min}}\)</span> (ratio of the maximum and minimum absolute values of eigenvalues)</p></li>
<li><p><span class="math notranslate nohighlight">\(\epsilon\)</span> is the error from the output state <span class="math notranslate nohighlight">\(| A^{-1}\bf{b} \rangle\)</span>.</p></li>
</ul>
<p>Then, the computational complexity of the currently most efficient HHL algorithm is <span class="math notranslate nohighlight">\(O(s \kappa \, \textrm{poly} (\log (s\kappa/\epsilon)))\)</span> [3]. Since <span class="math notranslate nohighlight">\(s=O(\textrm{poly}(\log N))\)</span> was assumed, if we focus on only <span class="math notranslate nohighlight">\(N\)</span>, the whole is also <span class="math notranslate nohighlight">\(O(\textrm{poly}(\log N))\)</span>. On the other hand, since the best conjugate gradient method of the classical algorithm has a computational complexity of <span class="math notranslate nohighlight">\(O(Ns\kappa \log(1/\epsilon))\)</span>[2], the HHL algorithm achieves exponential
acceleration for the matrix dimension <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>However, as mentioned in the introduction, this computational complexity is based on the assumption that the input state <span class="math notranslate nohighlight">\(|\mathbf{b}\rangle\)</span> is available, and does not take into account how the output <span class="math notranslate nohighlight">\(|A^{-1} \mathbf{b}\rangle\)</span> should be read out. If this input/output overhead takes <span class="math notranslate nohighlight">\(O(N)\)</span> time, the exponential acceleration described above would be offset, so the HHL algorithm should be used in situations where, for example, only sampling <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> would be useful
for practical purposes.</p>
</section>
<section id="Reference">
<h2>Reference<a class="headerlink" href="#Reference" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line">[1] A. W. Harrow, A. Hassidim, and S. Lloyd, “Quantum algorithm for linear systems of equations“, <a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502">Physical Review Letters 103 150502 (2009)</a></div>
<div class="line">[2] D. Dervovic, M. Herbster, P. Mountney, S. Severini, N. Usher, L. Wossnig, “Quantum linear systems algorithms: a primer“, <a class="reference external" href="https://arxiv.org/abs/1802.08227">arXiv:1802.08227</a></div>
<div class="line">[3] A. M. Childs, R. Kothari, and R. D. Somma, “Quantum Algorithm for Systems of Linear Equations with Exponentially Improved Dependence on Precision“, <a class="reference external" href="https://epubs.siam.org/doi/10.1137/16M1087072">SIAM Journal on Computing 46, 1920-1950 (2017)</a></div>
</div>
</section>
</section>

</article>
        <aside class="nftt-toc">
          
          <div class="mt-3 mb-1 my-lg-0 ps-xl-3 text-muted">
            <button class="btn btn-link link-dark p-lg-0 mb-2 mb-lg-0 text-decoration-none nftt-toc-toggle d-lg-none" type="button" data-bs-toggle="collapse" data-bs-target="#tocContents" aria-expanded="false" aria-controls="tocContents"
            >On this page <i class="ms-2 bi bi-chevron-expand"></i></button>
            <div class="title d-none d-lg-block">
              <i class="bi bi-file-earmark-text"></i>&nbsp;&nbsp;<span class="small">On this page</span>
            </div>
            <div class="collapse nftt-toc-collapse" id="tocContents">
              <nav id="TableOfContents">
                <ul>
<li><a class="reference internal" href="#">7-2. Harrow-Hassidim-Lloyd (HHL) Algorithm</a><ul>
<li><a class="reference internal" href="#Problem-Setup">Problem Setup</a></li>
<li><a class="reference internal" href="#Algorithm-Flow">Algorithm Flow</a><ul>
<li><a class="reference internal" href="#1.-prepare-the-input-state-|\mathbf{b}\rangle.">1. prepare the input state <span class="math notranslate nohighlight">\(|\mathbf{b}\rangle\)</span>.</a></li>
<li><a class="reference internal" href="#2.-Store-eigenvalues-of-A-in-auxiliary-clock-bits-using-the-phase-estimation-algorithm-with-unitary-operation-e^{i-A-}.">2. Store eigenvalues of <span class="math notranslate nohighlight">\(A\)</span> in auxiliary clock bits using the phase estimation algorithm with unitary operation <span class="math notranslate nohighlight">\(e^{i A }\)</span>.</a></li>
<li><a class="reference internal" href="#3.-Multiply-the-inverse-of-the-eigenvalues-by-a-control-rotation-using-auxiliary-clock-bits">3. Multiply the inverse of the eigenvalues by a control rotation using auxiliary clock bits</a><ul>
<li><a class="reference internal" href="#Note:-How-to-construct-a-controlled-rotation-gate">Note: How to construct a controlled rotation gate</a></li>
</ul>
</li>
<li><a class="reference internal" href="#4.-Inverse-operation-of-quantum-phase-estimation-to-restore-the-auxiliary-clock-bits">4. Inverse operation of quantum phase estimation to restore the auxiliary clock bits</a></li>
<li><a class="reference internal" href="#5.-Measure-auxiliary-bit-S.">5. Measure auxiliary bit <span class="math notranslate nohighlight">\(S\)</span>.</a></li>
</ul>
</li>
<li><a class="reference internal" href="#About-the-computational-complexity">About the computational complexity</a></li>
<li><a class="reference internal" href="#Reference">Reference</a></li>
</ul>
</li>
</ul>

              </nav>
            </div>
          </div>
          
        </aside>
      </div>
    </div>

    <footer class="nftt-footer">
      <nav id="paginator" class="py-4" aria-label="Documentation navigation">
    <div class="container">
      <ul class="pagination justify-content-between mb-0"><li class="page-item">
            <a href="7.1_quantum_phase_estimation_detailed.html" class="d-flex px-5 align-items-end" rel="prev" aria-label="Previous page: 7-1. Quantum Phase Estimation Algorithm in Detail: Application to Hydrogen Molecule as an Example">
              <span class="prev-page"><i class="bi bi-caret-left"></i></span>
              <div class="d-flex flex-column">
                <span class="text-small text-start text-muted">Previous</span>
                <span class="underline">7-1. Quantum Phase Estimation Algorithm in Detail: Application to Hydrogen Molecule as an Example</span>
              </div>
            </a>
          </li>
        <li class="page-item ms-auto">
            <a href="7.3_application_of_HHL_algorithm.html" class="d-flex px-5 align-items-end" rel="next" aria-label="Next page: 7-3. Portfolio optimization using HHL algorithm">
              <div class="d-flex flex-column">
                <span class="text-small text-end text-start text-muted">Next</span>
                <span class="underline">7-3. Portfolio optimization using HHL algorithm</span>
              </div>
              <span class="next-page"><i class="bi bi-caret-right"></i></span>
            </a>
          </li>
        
      </ul>
    </div>
  </nav>

      <div class="py-5 px-4 px-md-3">
  <div class="container">
    

    <div class="row">
      <div class="col-lg-12 text-center">
        <a class="brand-text d-inline-flex align-items-center mb-2 text-decoration-none" href="/" aria-label="Nefertiti-for-Sphinx">
          <span class="fs-6 fw-bold">Quantum Native Dojo</span>
        </a>
        
          <ul class="list-unstyled small text-muted">
            <li>2023, Quantum Native Dojo Contributors</li>
          </ul>
        
        
        <div class="built-with pt-2">
          Built with <a href="http://sphinx-doc.org">Sphinx 7.2.6</a> and <a href="https://github.com/danirus/sphinx-nefertiti">Nefertiti 0.3.0</a>
        </div>
        
      </div>
    </div>
  </div>
</div>
    </footer>
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"CommonHTML": {"undefinedFamily": "\"Source Serif Pro\", \"Yakumono\", \"Noto Serif JP\", \"Hiragino Mincho ProN\", \"STIXGeneral\", \"Arial Unicode MS\", serif"}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script>

    <script type="text/javascript" src="../_static/bootstrap.bundle.min.js"></script>
    <script type="text/javascript" src="../_static/sphinx-nefertiti.min.js"></script>
    
    <script type="text/javascript" src="../_static/doc_versions.js"></script>
  </body>
</html>