

<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
      <meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="docsearch:name" content="Quantum Native Dojo" />
    <meta name="docsearch:package_type" content="" />
    <meta name="docsearch:release" content="" />
    <meta name="docsearch:version" content="" />
    
      <title>7-1. Quantum Phase Estimation Algorithm in Detail: Application to Hydrogen Molecule as an Example &mdash; Quantum Native Dojo  documentation</title>
    
    <link rel="stylesheet" href="../_static/bootstrap-icons.css" type="text/css" />
          <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=e7352e39" />
          <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=e15ddae3" />
          <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
          <link rel="stylesheet" type="text/css" href="../_static/colorsets/sphinx-nefertiti-blue.min.css" />
          <link rel="stylesheet" type="text/css" href="../_static/fonts/nunito/stylesheet.css?v=0ed606bc" />
          <link rel="stylesheet" type="text/css" href="../_static/fonts/red-hat-mono/stylesheet.css?v=4eee5046" />
          <link rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=e15ddae3" />
        <link rel="index" title="Index" href="../genindex.html" />
        <link rel="search" title="Search" href="../search.html" />
        <link rel="top" title="Quantum Native Dojo  documentation" href="#" />
    <style>
      :root {
        --nftt-body-font-family: "Nunito", var(--nftt-font-sans-serif) !important;
        --nftt-font-monospace: "Red Hat Mono", var(--nftt-font-family-monospace) !important;
        --nftt-project-name-font: var(--nftt-body-font-family);
        --nftt-documentation-font: var(--nftt-body-font-family);
        --nftt-doc-headers-font: "Georgia", var(--nftt-documentation-font);}
      h1 *, h2 *, h3 *, h4 *, h5 *, h6 * { font-size: inherit; }
    </style>
  </head>
  <body>
    <header class="navbar navbar-expand-xl navbar-dark nftt-navbar flex-column fixed-top">
      <div class="skip-links container-fluid visually-hidden-focusable overflow-hidden justify-content-start">
        <div class="border-bottom mb-2 pb-2 w-100">
          <a class="d-none d-md-inline-flex p-2 m-1" href="#sidebar-filter">Skip to docs navigation</a>
          <a class="d-inline-flex p-2 m-1" href="#content">Skip to main content</a>
        </div>
      </div>
      <nav class="container-xxl nftt-gutter flex-wrap flex-xl-nowrap" aria-label="Main navigation">
        <div class="nftt-navbar-toggler">
          <button class="navbar-toggler p-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#sidebar" aria-controls="sidebar" aria-label="Toggle documentation navigation">
            <i class="bi bi-list"></i>
          </button>
        </div>
          <a href="../index.html"
              
              class="navbar-brand p-0 me-0 md-lg-2"
          ><span class="brand-text">Quantum Native Dojo</span></a>
        
        <div class="d-flex d-xl-none">
          <button class="navbar-toggler p-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#nfttSearch" aria-controls="nfttSearch" aria-label="Search">
            <i class="bi bi-search"></i>
          </button>
          <button class="navbar-toggler p-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#nfttNavbar" aria-controls="nfttNavbar" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
        </div>
        
<div class="offcanvas-xl offcanvas-end flex-grow-1" tabindex="-1" id="nfttSearch" aria-labelledby="nfttSearchOffcanvasLabel" data-bs-scroll="true">
  <div class="offcanvas-header px-4 pb-0">
    <h5 class="offcanvas-title fw-bold" id="nfttSearchOffcanvasLabel">Search the documentation</h5>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close" data-bs-target="#nfttSearch"></button>
  </div>
  <div class="offcanvas-body p-4 pt-0 p-xl-0 px-xl-3">
    <hr class="d-xl-none text-white-50">
    <ul class="navbar-nav flex-row align-items-center flex-wrap ms-md-auto">
      <li class="nav-item col-12 col-xl-auto">
        <form id="nftt-search-form" action="../search.html" method="get">
          <div class="input-group">
            <input type="text" name="q" class="form-control" placeholder="Search docs" aria-label="Search" aria-describedby="button-search">
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
            <button class="btn btn-primary" type="submit" id="button-search" aria-label="Search"><i class="bi bi-search"></i></button>
          </div>
        </form>
      </li>
    </ul>
  </div>
</div>

        <div class="offcanvas-xl offcanvas-end" tabindex="-1" id="nfttNavbar" aria-labelledby="nfttNavbarOffcanvasLabel" data-bs-scroll="true">
          <div class="offcanvas-header px-4 pb-0">
            <div class="offcanvas-title navbar-brand" id="nfttNavbarOffcanvasLabel"><span class="brand-text">Nefertiti for Sphinx</span></div>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close" data-bs-target="#nfttNavbar"></button>
          </div>
          <div class="offcanvas-body p-4 pt-0 p-xl-0 px-xl-3">
            <hr class="d-xl-none text-white-50">
            <ul class="navbar-nav flex-row align-items-center flex-wrap ms-lg-auto">
              
              <!-- version_dropdown.html -->

              
              <!-- colorscheme_dropdown.html -->
<li class="nav-item dropdown">
  <a class="nav-link d-flex py-2 px-0 px-xl-2 dropdown-toggle align-items-center" id="snftt-luz" href="#" data-bs-toggle="dropdown" data-bs-display="static" aria-expanded="false" aria-label="Toggle light/dark">
    <i class="bi bi-circle-half" data-snftt-luz-icon-active></i>
    <span id="snftt-luz-text" class="d-xl-none small ms-2">Toggle light/dark</span>
  </a>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="snftt-luz-text">
    <li>
      <h6 class="dropdown-header">Light/dark</h6>
    </li>
    <li>
      <a class="dropdown-item d-flex align-items-center" data-snftt-luz="light" href="#" aria-pressed="false">
        <span class="small">
          <i class="bi bi-sun" data-snftt-luz-icon="light"></i>
        </span>
        <span class="small ms-3">Light</span>
        <i class="bi bi-check ms-auto"></i>
      </a>
    </li>
    <li>
      <a class="dropdown-item d-flex align-items-center" data-snftt-luz="dark" href="#" aria-pressed="false">
        <span class="small">
          <i class="bi bi-moon-stars" data-snftt-luz-icon="dark"></i>
        </span>
        <span class="small ms-3">Dark</span>
        <i class="bi bi-check ms-auto"></i>
      </a>
    </li>
    <li>
      <a class="dropdown-item current d-flex align-items-center" data-snftt-luz="default" href="#" aria-pressed="false">
        <span class="small">
          <i class="bi bi-circle-half" data-snftt-luz-icon="default"></i>
        </span>
        <span class="small ms-3">Default</span>
        <i class="bi bi-check ms-auto"></i>
      </a>
    </li>
  </ul>
</li>
            </ul>
          </div>
        </div>
      </nav>
    </header>

    <div class="container-fluid">
      <div class="nftt-gutter nftt-page">
        <aside class="nftt-sidebar">
          <div class="nftt-sidebar-content">
            <div class="title d-none d-xl-block">
              <i class="bi bi-book"></i>&nbsp;&nbsp;<span>Index</span>
            </div>
            <div id="sidebar" tabindex="-1" class="offcanvas-xl offcanvas-start" aria-labelledby="nfttSidebarOffcanvasLabel">
                <!-- danirus sidebartemplate: "globaltoc.html" --><div class="offcanvas-header border-bottom">
  <h5 class="offcanvas-title fw-bold" id="nfttSidebarOffcanvasLabel">
    Table of contents
  </h5>
  <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close" data-bs-target="#sidebar"></button>
</div>

<div class="offcanvas-body">
  <nav class="toc" aria-label="Main menu">
    <div class="mb-3 p-1 pt-3 pb-4 border-bottom">
      <input id="sidebar-filter" type="text" name="filter" class="form-control form-control-sm" placeholder="filter" aria-label="filter">
    </div>
    <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/0_prologue.html">Chapter 0: What is a Quantum Computer ?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/1_quantum_information_foundation.html">Chapter 1: Fundamentals of Quantum Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/1.1_qubit_representation.html">1-1. Qubit Representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/1.2_qubit_operations.html">1-2. Qubit Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/1.3_multiqubit_representation_and_operations.html">1-3. Multiqubit representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/1.3_multiqubit_representation_and_operations.html#Column:-What-is-a-universal-gate-set?">Column: What is a universal gate set?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/1.4_quantum_circuit_diagram.html">1-4. Quantum Circuit Diagram</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/2_introduction_to_quantum_algorithms.html">Chapter 2: Introduction to Quantum Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/2.1_NISQ_and_long_term.html">2-1. NISQ algorithm and long-term algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/2.2_Hadamard_test.html">2-2. Hadamard test</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/2.3_quantum_Fourier_transform.html">2-3. Quantum Fourier transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/2.4_phase_estimation_beginner.html">2-4. Phase Estimation Algorithm（Introductory）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/3_execution_environments_of_quantum_algorithms.html">Chapter 3: Execution Environment for Quantum Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/3.1_Qulacs_tutorial.html">3-1. Qulacs_tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/3.2_Qiskit_IBMQ.html">3-2. Qiskit_IBMQ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/4_quantum_dynamics_simulation.html">Chapter4 Quantum dynamics simulation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/4.1_quantum_simulation.html">4-1. Quantum Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/4.2_trotter_decomposition.html">4-2. Trotter Decomposition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/5_VQC_based_algorithms.html">Chapter 5 Algorithms Based on Variational Quantum Circuits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/5.1_variational_quantum_eigensolver.html">5-1. Variational Quantum Eigensolver（VQE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/5.2_Quantum_Circuit_Learning.html">5-2. Quantum Circuit Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/5.3_quantum_approximate_optimazation_algorithm.html">5-3. Quantum Approximate Optimazation Algorithm (QAOA)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/6_quantum_chemistry_calculation.html">Chapter 6 Quantum chemistry calculation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/6.1_openfermion_basics.html">6-1. OpenFermion Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/6.2_qulacs_VQE.html">6-2. Variational Quantum Eigensolver (VQE) Implementation using Qulacs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/6.3_subspace_search_VQE.html">6-3. Calculation of Excited States using Subspace-Search Variational Quantum Eigensolver</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/7_quantum_phase_estimation.html">chapter 7 Quantum phase estimation algorithm and its application</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/7.1_quantum_phase_estimation_detailed.html">7-1. Quantum Phase Estimation (QPE) Algorithm Detailed：Hydrogen Molecule as Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/7.2_Harrow-Hassidim-Lloyd_algorithm.html">7-2. Harrow-Hassidim-Lloyd (HHL) Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/7.3_application_of_HHL_algorithm.html">7-3. Portofolio Optimization by HHL Algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/8_quantum_search_algorithm.html">Chapter 8: Quantum Search Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/8.1_oracle.html">8-1. oracle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/8.2_Grovers_algorithm.html">8-2. Grover’s algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/9_quantum_error_correction.html">Chapter 9 Quantum Error Correction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/9.1_error_correction.html">9-1. classical error</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/9.2_quantum_error_correction.html">9-2. quantum error</a></li>
</ul>
</li>
</ul>

  </nav>
  <template data-toggle-item-template>
    <button class="btn btn-sm btn-link toctree-expand" type="button">
      <i class="bi bi-caret-right"></i>
      <span class="visually-hidden">Toggle menu contents</span>
    </button>
  </template>
</div>
            </div>
          </div>
        </aside>
        <article id="content" class="nftt-content" role="main">
    <section id="7-1.-Quantum-Phase-Estimation-Algorithm-in-Detail:-Application-to-Hydrogen-Molecule-as-an-Example">
<h1>7-1. Quantum Phase Estimation Algorithm in Detail: Application to Hydrogen Molecule as an Example<a class="headerlink" href="#7-1.-Quantum-Phase-Estimation-Algorithm-in-Detail:-Application-to-Hydrogen-Molecule-as-an-Example" title="Link to this heading">¶</a></h1>
<p>In this section, we review the Quantum Phase Estimation (QPE) algorithm and try to find the eigenvalues ​​of the Hamiltonian of a quantum many-body system (hydrogen molecule) using QPE. In the process, we will learn in detail the flow and techniques for applying QPE to real problems.</p>
<section id="Review-of-Phase-Estimation">
<h2>Review of Phase Estimation<a class="headerlink" href="#Review-of-Phase-Estimation" title="Link to this heading">¶</a></h2>
<p>As we have already learned in <a class="reference external" href="2.4_phase_estimation_beginner.ipynb">2-4. Phase estimation algorithm (introductory)</a>, given a unitary matrix <span class="math notranslate nohighlight">\(U\)</span>, QPE extracts its eigenvalues ​​<span class="math notranslate nohighlight">\(e^{i \lambda}\)</span> as bit strings. By using QPE as a subroutine, it is expected that many problems such as prime factorization and quantum many-body energy calculation (which can be reduced to the eigenvalue problem of unitary matrices) can be solved much faster than on classical computers.</p>
<p>Let us recall the transformation of QPE specifically. Let <span class="math notranslate nohighlight">\(| u_i \rangle\)</span> be the eigenvector corresponding to the <span class="math notranslate nohighlight">\(i\)</span>-th eigenvalue <span class="math notranslate nohighlight">\(e^{i \lambda_i}\)</span> of <span class="math notranslate nohighlight">\(U\)</span> (<span class="math notranslate nohighlight">\(U | u_i \rangle = e^{i \lambda_i} | u_i \rangle\)</span>). At this time, using the control unitary operation <span class="math notranslate nohighlight">\(\Lambda (U)\)</span> and the quantum Fourier transform, the QPE realizes the following transform.</p>
<div class="math notranslate nohighlight">
\[| u_i \rangle | 0 \rangle{}^{\otimes{t}} \xrightarrow{\text{QPE}} | u_i \rangle | \tilde{\lambda_i} \rangle.\]</div>
<p>where <span class="math notranslate nohighlight">\(| 0 \rangle{}^{\otimes{t}}\)</span> are <span class="math notranslate nohighlight">\(t\)</span> auxiliary qubits and <span class="math notranslate nohighlight">\(\tilde{\lambda_i}=j_1j_2 \ldots j_t\)</span> is a bit string that is binary expression of <span class="math notranslate nohighlight">\(\lambda_i\)</span> up to the <span class="math notranslate nohighlight">\(t\)</span>th digit</p>
<div class="math notranslate nohighlight">
\[\frac{\lambda_i}{2 \pi} = \frac{j_1}{2} + \frac{j_2}{2^2} + \ldots + \frac{j_t}{2^t} = 0.j_1 j_2 \ldots j_t\]</div>
<p>(The <span class="math notranslate nohighlight">\((t+1)\)</span> th digit and after are omitted.)</p>
<p>To run this QPE on practical problems, it is believed that a quantum computer with error correction is required (long-term algorithm). The main reason is</p>
<ul class="simple">
<li><p>number of auxiliary bits</p></li>
<li><p>complexity of control unitary gate <span class="math notranslate nohighlight">\(\Lambda (U^{2^{k-1}})\)</span> (<span class="math notranslate nohighlight">\(k =1, ..., t\)</span>)</p></li>
</ul>
<p>First, regarding the number of ancillary bits, for example, 50 or more ancillary bits are required to obtain <span class="math notranslate nohighlight">\(\lambda_i\)</span> with the precision of double-precision real numbers used in modern classical computers. And with such a large number of ancillary bits (i.e. large <span class="math notranslate nohighlight">\(t\)</span> ), the control unitary gate <span class="math notranslate nohighlight">\(\Lambda (U^{2^{k-1}})\)</span> (<span class="math notranslate nohighlight">\(k =1, ..., t\)</span>) for very large powers of <span class="math notranslate nohighlight">\(U\)</span>. The difficulty of preparing such a control gate depends on what kind of matrix you consider for
<span class="math notranslate nohighlight">\(U\)</span> , but in general it is not easy.</p>
<p>As we will see later, in the case of the eigenvalue problem of the Hermitian matrix <span class="math notranslate nohighlight">\(H\)</span>, which is one of the most promising applications of QPE, <span class="math notranslate nohighlight">\(U\)</span> is the time evolution operator by <span class="math notranslate nohighlight">\(H\)</span>. That is, $ U = e^{-iH:nbsphinx-math:<cite>tau</cite>}$ (where <span class="math notranslate nohighlight">\(\tau\)</span> is a constant). Therefore, the large power of <span class="math notranslate nohighlight">\(U\)</span> means simulating development of <span class="math notranslate nohighlight">\(H\)</span> for a long time (exponential to the reciprocal of precision) which is very difficult.</p>
</section>
<section id="Iterative-Quantum-Phase-Estimation">
<h2>Iterative Quantum Phase Estimation<a class="headerlink" href="#Iterative-Quantum-Phase-Estimation" title="Link to this heading">¶</a></h2>
<p>In fact, if we’re only interested in the eigenvalues ​​of <span class="math notranslate nohighlight">\(U\)</span> and don’t need the eigenstates, we can reduce the QPE ancillary bits. This is called Iterative Quantum Phase Estimation (IQPE), <a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.76.030306">PhysRevA.76.030306</a>, and is equivalent to the method introduced in the section “Introduction: Improving the Hadamard test” of <a class="reference external" href="2.4_phase_estimation_beginner.ipynb">chapter 2-4</a>, we will describe it here again.</p>
<p>IQPE is a method of deterministically obtaining bit strings of binary expansion of eigenvalues ​​for each digit. Only one auxiliary bit is required, and one digit value (<span class="math notranslate nohighlight">\(j_k\)</span>) of the eigenvalue binary decimal representation <span class="math notranslate nohighlight">\(0.j_1...j_t\)</span> is obtained for each iteration. The steps are (<span class="math notranslate nohighlight">\(k = t, t-1, \ldots, 1\)</span>):</p>
<section id="k-=-t">
<h3><span class="math notranslate nohighlight">\(k = t\)</span><a class="headerlink" href="#k-=-t" title="Link to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Put a Hadamard gate on the auxiliary bit</p></li>
</ol>
<div class="math notranslate nohighlight">
\[| 0 \rangle | u_i \rangle \xrightarrow{H} \frac{1}{\sqrt{2}} \left( |0\rangle + |1\rangle \right) | u_i \rangle\]</div>
<ol class="arabic simple" start="2">
<li><p>Multiply the ancillary bits by <span class="math notranslate nohighlight">\(\Lambda (U^{2^{t-1}})\)</span></p></li>
</ol>
<div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{2}} \left( |0\rangle + |1\rangle \right) | u_i \rangle  \xrightarrow{\Lambda (U^{2^{t-1}})} \frac{1}{\sqrt{2}} \left(| 0 \rangle + e^{i \pi j_t} | 1 \rangle \right) | u_i \rangle\]</div>
<ol class="arabic simple" start="3">
<li><p>Apply a Hadamard gate to the auxiliary bit and measure</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{2}} \left(| 0 \rangle + e^{i \pi j_t} | 1 \rangle \right) | u_i \rangle  \xrightarrow{H} \frac{1}{2} [ (1 + e^{i \pi j_t})| 0 \rangle + (1 - e^{i \pi j_t}) | 1 \rangle]   |u_i \rangle =  | j_t \rangle | u_i \rangle  \xrightarrow{\textrm{Measure}} j_t\]</div>
<ol class="arabic simple" start="4">
<li><p>Reflect the measurement result <span class="math notranslate nohighlight">\(j_t\)</span> to the accumulation phase <span class="math notranslate nohighlight">\(\Phi(t)\)</span>: <span class="math notranslate nohighlight">\(\Phi(t)\)</span>: <span class="math notranslate nohighlight">\(\Phi(t) = \pi \cdot \frac{j_t}{2} = \pi 0. j_t\)</span></p></li>
</ol>
</section>
<section id="k-=-t-1,-t-2,-\ldots,-1">
<h3><span class="math notranslate nohighlight">\(k = t-1, t-2, \ldots, 1\)</span><a class="headerlink" href="#k-=-t-1,-t-2,-\ldots,-1" title="Link to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Apply a Hadamard gate to the auxiliary bit</p></li>
</ol>
<div class="math notranslate nohighlight">
\[| 0 \rangle | u_i \rangle \xrightarrow{H} \frac{1}{\sqrt{2}} \left( |0\rangle + |1\rangle \right) | u_i \rangle\]</div>
<ol class="arabic simple" start="2">
<li><p>Apply Z rotation gate <span class="math notranslate nohighlight">\(R_Z ( \Phi(k+1) )\)</span> to the auxiliary bit (where <span class="math notranslate nohighlight">\(R_Z(\theta)=e^{i\theta/2 Z}, \Phi(k+1) = \ pi 0.j_{k+1} j_{k+2} \ldots j_{t}\)</span>)</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{2}} \left( |0\rangle + |1\rangle \right) | u_i \rangle \xrightarrow{R_Z} \frac{e^{i\Phi(k+1)/2}}{\sqrt{2}} (| 0 \rangle + e^{- i \pi 0.j_{k+1} j_{k+2} \ldots j_{t}} | 1 \rangle) | u_i \rangle\]</div>
<ol class="arabic simple" start="3">
<li><p>Multiply the ancillary bits by <span class="math notranslate nohighlight">\(\Lambda (U^{2^{k-1}})\)</span></p></li>
</ol>
<div class="math notranslate nohighlight">
\[\frac{e^{i\Phi(k+1)/2}}{\sqrt{2}} (| 0 \rangle + e^{- i \pi 0.j_{k+1} j_{k+2} \ldots j_{t}} | 1 \rangle) | u_i \rangle \xrightarrow{\Lambda (U^{2^{k-1}})} \frac{e^{i\Phi(k+1)/2}}{\sqrt{2}} (| 0 \rangle + e^{i \pi j_k} | 1 \rangle) | u_i \rangle\]</div>
<ol class="arabic simple" start="4">
<li><p>Apply a Hadamard gate to the auxiliary bit and measure</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\frac{e^{i\Phi(k+1)/2}}{\sqrt{2}} (| 0 \rangle + e^{i \pi j_k} | 1 \rangle) | u_i \rangle  \xrightarrow{H} \frac{e^{i\Phi(k+1)/2}}{2}  [(1 + e^{i \pi j_k})| 0 \rangle + (1 - e^{i \pi j_k}) | 1 \rangle] | u_i \rangle = e^{i\Phi(k+1)/2} | j_k \rangle | u_i \rangle  \xrightarrow{\textrm{Measure}} j_k\]</div>
<ol class="arabic simple" start="5">
<li><p>Refleat the measurement result <span class="math notranslate nohighlight">\(j_k\)</span> to the accumulation phase <span class="math notranslate nohighlight">\(\Phi(k)\)</span>:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\Phi(k) = \frac{\Phi(k+1)}{2} + \pi \cdot \frac{j_k}{2} = \pi 0.j_{k} j_{k+1} \ldots j_{t}\]</div>
</section>
<section id="After-measuring-all-j_k-(k-=-t,-t-1,-\ldots,-1)">
<h3>After measuring all <span class="math notranslate nohighlight">\(j_k\)</span> (<span class="math notranslate nohighlight">\(k = t, t-1, \ldots, 1\)</span>)<a class="headerlink" href="#After-measuring-all-j_k-(k-=-t,-t-1,-\ldots,-1)" title="Link to this heading">¶</a></h3>
<p>We get the desired phase.</p>
<div class="math notranslate nohighlight">
\[\lambda_i = 2 \Phi(1) = 2 \pi 0.j_1.j_2 \ldots j_{t}\]</div>
</section>
</section>
<section id="Example:-Calculation-of-the-ground-state-energy-of-the-hydrogen-molecular-Hamiltonian-using-the-quantum-phase-estimation-algorithm">
<h2>Example: Calculation of the ground state energy of the hydrogen molecular Hamiltonian using the quantum phase estimation algorithm<a class="headerlink" href="#Example:-Calculation-of-the-ground-state-energy-of-the-hydrogen-molecular-Hamiltonian-using-the-quantum-phase-estimation-algorithm" title="Link to this heading">¶</a></h2>
<p>Let’s calculate the ground state energy of the hydrogen molecule using the above iterative phase estimation algorithm (the following content is based on the paper [1]).</p>
<p>As we learned in <a class="reference external" href="4.1_quantum_simulation.ipynb">Section 4-1</a> and <a class="reference external" href="6.1_openfermion_basics.ipynb">Section 6-1</a>, the ground state energy of the hydrogen molecule is the smallest eigenvalue of Hamiltonian <span class="math notranslate nohighlight">\(H\)</span>. In QPE and IQPE, the eigenvalue problem of Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> is solved by <strong>finding the eigenvalues ​​of its time evolution operator</strong> <span class="math notranslate nohighlight">\(U = e^{−iH \tau}\)</span>.</p>
<p>Here, <span class="math notranslate nohighlight">\(E_{\text{min}}\)</span> and <span class="math notranslate nohighlight">\(E_{\text{max}}\)</span> are the smallest and largest eigenvalues. <span class="math notranslate nohighlight">\(\tau\)</span> is some constant and is set so that <span class="math notranslate nohighlight">\([ E_{\text{min}}, E_{\text{max}}]\)</span> fit in <span class="math notranslate nohighlight">\([0, 2\pi]\)</span>. (add a constant shift if necessary). Although in QPE and IQPE, the phase of the eigenvalue of <span class="math notranslate nohighlight">\(U\)</span> has <span class="math notranslate nohighlight">\(2\pi\)</span> ambiguity, the eigenvalues ​​of <span class="math notranslate nohighlight">\(H\)</span> can be uniquely restored from the eigenvalues ​​of <span class="math notranslate nohighlight">\(U\)</span> this way.</p>
<p>The steps required to calculate the basis energy are:</p>
<ol class="arabic simple" start="0">
<li><p>(Reduce Hamiltonian size using symmetry etc.)</p></li>
<li><p>Accurate approximation of Hamiltonian time evolution operator <span class="math notranslate nohighlight">\(U=e^{-iH\tau}\)</span></p></li>
<li><p>Decompose the control time evolution operator into a gate set that can be easily executed on a quantum computer and implement it</p></li>
<li><p>Prepare an initial state with sufficient overlap with the ground state</p></li>
<li><p>Measuring energy eigenvalues ​​with IQPE</p></li>
</ol>
<p>A detailed explanation of the method and an implementation example are given below.</p>
<section id="0.-(Reduce-Hamiltonian-size-using-symmetry-etc.)">
<h3>0. (Reduce Hamiltonian size using symmetry etc.)<a class="headerlink" href="#0.-(Reduce-Hamiltonian-size-using-symmetry-etc.)" title="Link to this heading">¶</a></h3>
<p>This step is necessary to reduce resources as much as possible when actually running IQPE on a simulator or on a real machine, and is not theoretically essential. For details, refer to reference [1], but if we map the second quantized Hamiltonian of the hydrogen molecule (STO-6G basis) to the qubit system by the Bravyi-Kitaev transformation, we get a 4 qubit Hamiltonian = <span class="math notranslate nohighlight">\(16 \times 16\)</span> matrix. However, if we partially diagonalize the Hamiltonian using the <strong>symmetry of the Hamiltonian</strong>
(such as the law of conservation of the number of electrons), we can get the ground state with 2 qubits, and the Hamiltonian has only 6 kinds of terms as follows.</p>
<div class="math notranslate nohighlight">
\[H = \sum_i g_i H_i = g_0 I + g_1 Z_0 + g_2 Z_1 + g_3 Z_0 Z_1 + g_4 Y_0 Y_1 + g_5 X_0 X_1\]</div>
<p>where the coefficient <span class="math notranslate nohighlight">\(g_i\)</span> is a real number and its value depends on the interatomic distance (arrangement) of hydrogen molecules. Readers unfamiliar with chemistry should just understand that the above Hermitian matrix corresponding to the hydrogen molecule exists and that it is important to find the minimum eigenvalue of it.</p>
<p>For the interested readers, we present how to construct the reduced Hamiltonian from scratch. First, let’s follow reference [1] and construct the full qubit Hamiltoinian with the Bravyi-Kitaev transformation. Please check out the QURI Parts tutorial page on <a class="reference external" href="https://quri-parts.qunasys.com/tutorials/quantum_chemistry/qubit_operator_mapping">Fermion-Qubit mapping</a> for more details.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="kn">from</span> <span class="nn">quri_parts.pyscf.mol</span> <span class="kn">import</span> <span class="n">get_spin_mo_integrals_from_mole</span>
<span class="kn">from</span> <span class="nn">quri_parts.openfermion.mol</span> <span class="kn">import</span> <span class="n">get_qubit_mapped_hamiltonian</span>
<span class="kn">from</span> <span class="nn">quri_parts.openfermion.transforms</span> <span class="kn">import</span> <span class="n">bravyi_kitaev</span>
<span class="kn">from</span> <span class="nn">quri_parts.core.operator</span> <span class="kn">import</span> <span class="n">commutator</span><span class="p">,</span> <span class="n">zero</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s2">&quot;H 0 0 0; H 0 0 0.7&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;sto-6g&quot;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">full_space</span><span class="p">,</span> <span class="n">spin_mo_eint</span> <span class="o">=</span> <span class="n">get_spin_mo_integrals_from_mole</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">)</span>
<span class="n">qubit_hamiltonian</span><span class="p">,</span> <span class="n">bk_op_mapper</span><span class="p">,</span> <span class="n">bk_state_mapper</span> <span class="o">=</span> <span class="n">get_qubit_mapped_hamiltonian</span><span class="p">(</span><span class="n">full_space</span><span class="p">,</span> <span class="n">spin_mo_eint</span><span class="p">,</span> <span class="n">bravyi_kitaev</span><span class="p">)</span>

<span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="si">}</span><span class="s2"> * </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(0.17963+0j) * Z0
(-0.04975+0j) * I
(0.17963+0j) * Z0 Z1
(-0.24131+0j) * Z2
(-0.24131+0j) * Z1 Z2 Z3
(0.04482+0j) * Y0 Z1 Y2
(0.04482+0j) * X0 Z1 X2
(0.04482+0j) * X0 Z1 X2 Z3
(0.04482+0j) * Y0 Z1 Y2 Z3
(0.17059+0j) * Z1
(0.12303+0j) * Z0 Z2
(0.16786+0j) * Z0 Z1 Z2
(0.16786+0j) * Z0 Z1 Z2 Z3
(0.12303+0j) * Z0 Z2 Z3
(0.17671+0j) * Z1 Z3
</pre></div></div>
</div>
<p>Then we exploit some symmetry properties and reduce the Hamiltonian above. Note that we will be acting on the Hartree Fock state:</p>
<p><span class="math">\begin{equation}
|\text{HF}\rangle = c_0^{\dagger}c_1^{\dagger}|0000\rangle,
\end{equation}</span></p>
<p>which takes the form</p>
<p><span class="math">\begin{equation}
|\text{HF}\rangle_{\text{BK}} = |0001\rangle
\end{equation}</span></p>
<p>under the Bravi-Kitaev transform. In QURI Parts, we can show this by:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bk_state_mapper</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
ComputationalBasisState(qubit_count=4, bits=0b1, phase=0π/2)
</pre></div></div>
</div>
<p>As the Hamiltonian contains only Pauli operators <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(Z\)</span> on qubit 1 and 3, they act as identity operator on <span class="math notranslate nohighlight">\(|\text{HF}\rangle_{\text{BK}}\)</span> on qubit 1 and 3. This means that we can remove these qubits from the Hamiltonian and relabel qubit 2 as qubit 1.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">quri_parts.core.operator</span> <span class="kn">import</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">PAULI_IDENTITY</span><span class="p">,</span> <span class="n">pauli_label</span>

<span class="k">def</span> <span class="nf">get_reduced_operator</span><span class="p">(</span><span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Operator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute reduced hamiltonian</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">reduced_op</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">()</span>
    <span class="n">pauli_map</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;Z&quot;</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">PAULI_IDENTITY</span><span class="p">:</span>
            <span class="n">reduced_op</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">PAULI_IDENTITY</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">new_str</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">op</span><span class="o">.</span><span class="n">index_and_pauli_id_list</span><span class="p">):</span>
            <span class="c1"># Remove Z1 and Z3 from the Hamiltonian as they both act as identity</span>
            <span class="c1"># when acting on the Hartree-Fock state.</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pauli_map</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">new_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pauli_map</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Symmetry is not satisfied.&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_str</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">reduced_op</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">PAULI_IDENTITY</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reduced_op</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">pauli_label</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_str</span><span class="p">)),</span> <span class="n">coeff</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reduced_op</span>

<span class="n">reduced_hamiltonian</span> <span class="o">=</span> <span class="n">get_reduced_operator</span><span class="p">(</span><span class="n">qubit_hamiltonian</span><span class="p">)</span>

<span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">reduced_hamiltonian</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="si">}</span><span class="s2"> * </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(0.35925+0j) * Z0
(0.29755+0j) * I
(-0.48262+0j) * Z1
(0.08964+0j) * Y0 Y1
(0.08964+0j) * X0 X1
(0.58178+0j) * Z0 Z1
</pre></div></div>
</div>
<p>As there could be terms in the Hamiltonian that commutes with all the Pauli strings in the Hamiltonian, in this case <span class="math notranslate nohighlight">\(Z_0 Z_1\)</span> and the identity operator, we can remove them from the Hamiltonian for further reducing the size of the Hamiltonian.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">matrix_power</span><span class="p">,</span> <span class="n">eig</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">eigsh</span>
<span class="kn">from</span> <span class="nn">quri_parts.core.operator</span> <span class="kn">import</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">pauli_label</span><span class="p">,</span> <span class="n">get_sparse_matrix</span>

<span class="k">def</span> <span class="nf">remove_all_commuting_terms</span><span class="p">(</span><span class="n">reduced_op</span><span class="p">:</span> <span class="n">Operator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove terms that commute with rest of the Hamiltonian</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_commuting</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">op1</span> <span class="ow">in</span> <span class="n">reduced_op</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">op2</span> <span class="ow">in</span> <span class="n">reduced_op</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">op2</span> <span class="ow">in</span> <span class="n">all_commuting</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">commutator</span><span class="p">(</span><span class="n">Operator</span><span class="p">({</span><span class="n">op1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}),</span> <span class="n">Operator</span><span class="p">({</span><span class="n">op2</span><span class="p">:</span> <span class="mi">1</span><span class="p">}))</span> <span class="o">!=</span> <span class="n">zero</span><span class="p">():</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_commuting</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>

    <span class="p">[</span><span class="n">reduced_op</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">all_commuting</span><span class="p">]</span>
    <span class="k">return</span>

<span class="n">remove_all_commuting_terms</span><span class="p">(</span><span class="n">reduced_hamiltonian</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;reduced_hamiltonian:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">reduced_hamiltonian</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="si">}</span><span class="s2"> * </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
reduced_hamiltonian:

(0.35925+0j) * Z0
(-0.48262+0j) * Z1
(0.08964+0j) * Y0 Y1
(0.08964+0j) * X0 X1
</pre></div></div>
</div>
<p>We have finally obtained <span class="math notranslate nohighlight">\(H_{\textrm{eff}}\)</span>. Now, let’s diagonalize it. The unit of energy used is <a class="reference external" href="https://en.wikipedia.org/wiki/Hartree">Hartree (Ha)</a>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sparse_matrix</span> <span class="o">=</span> <span class="n">get_sparse_matrix</span><span class="p">(</span><span class="n">reduced_hamiltonian</span><span class="p">)</span>
<span class="n">exact_eigenvalue</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SA&#39;</span><span class="p">)</span> <span class="c1">## only smallest eigenvalue and eigenvector are calculated</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;exact_eigenvalue: </span><span class="si">{:.10f}</span><span class="s1"> Ha&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exact_eigenvalue</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">## print eigenvalue up to 10 digits after decimal point</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
exact_eigenvalue: -0.8607485699 Ha
</pre></div></div>
</div>
</section>
<section id="1.-Accurate-approximation-of-Hamiltonian-time-evolution-operator-U=e^{-iH\tau}">
<h3>1. Accurate approximation of Hamiltonian time evolution operator <span class="math notranslate nohighlight">\(U=e^{-iH\tau}\)</span><a class="headerlink" href="#1.-Accurate-approximation-of-Hamiltonian-time-evolution-operator-U=e^{-iH\tau}" title="Link to this heading">¶</a></h3>
<p>To implement the control unitary operation <span class="math notranslate nohighlight">\(\Lambda (U^{2^k})\)</span> used in IQPE, we first implement the time evolution operator <span class="math notranslate nohighlight">\(U = e^{−iH \tau}\)</span> in a quantum circuit. First, noting that the constant terms <span class="math notranslate nohighlight">\(g_0 I\)</span> and <span class="math notranslate nohighlight">\(g_3 Z_0 Z_1\)</span> commute with all other terms in the Hamiltonian, <span class="math notranslate nohighlight">\(U\)</span> becomes</p>
<div class="math notranslate nohighlight">
\[e^{−iH \tau} = \exp \left[−i \tau \sum_i g_i H_i \right] = \exp[−i \tau g_0 I] \exp[−i \tau g_3 Z_0 Z_1] \exp[−i \tau H_{\textrm{eff}}]\]</div>
<p>Here, <span class="math notranslate nohighlight">\(H_{\text{eff}}\)</span> is</p>
<div class="math notranslate nohighlight">
\[H_{\text{eff}} = g_1 Z_0 + g_2 Z_1 + g_4 Y_0 Y_1 + g_5 X_0 X_1\]</div>
<p>Since the contributions of <span class="math notranslate nohighlight">\(g_0 I\)</span> and <span class="math notranslate nohighlight">\(g_3 Z_0 Z_1\)</span> to the eigenvalues ​​of the parts can easily be added later, in the following we calculate the eigenvalues ​​of <span class="math notranslate nohighlight">\(H_{\textrm{eff}}\)</span> using IQPE of <span class="math notranslate nohighlight">\(U_{\text{eff}} := e^{−i H_{\text{eff}} \, \tau}\)</span> .</p>
<p>Trotter decomposition of <span class="math notranslate nohighlight">\(U_{\text{eff}}\)</span> is</p>
<div class="math notranslate nohighlight">
\[U_{\text{eff}} = \exp \left[−i \tau \sum_{i=1,2,4,5} g_i H_i \right] \approx U_{\text{Trot}}^{(N)} (\tau) := \left( \prod_{i=1,2,4,5} \exp[-i g_i H_i \tau/N] \right)^N\]</div>
<p>Each term of the product appearing in <span class="math notranslate nohighlight">\(U_{\text{Trot}}^{(N)}\)</span> is a multi-qubit Pauli rotation gate, that is, the exponential function of the Pauli matrix product <span class="math notranslate nohighlight">\(\exp(i\theta P)\)</span> , making it easy to implement as a product of simple quantum gates. Now we have approximately implemented <span class="math notranslate nohighlight">\(U_{\textrm{eff}}\)</span> on a quantum circuit.</p>
<p>Let’s examine the errors in this approximation. When we do a rough analytical evaluation, we have [2]</p>
<div class="math notranslate nohighlight">
\[\left| U_{\textrm{eff}} - U_{\textrm{Trot}}^{(N)} (\tau) \right| \sim \frac{\tau^2}{2N} \sum_{i &gt; j} | [H_i, H_j] |\]</div>
<p>According to this expression, it is possible to take <span class="math notranslate nohighlight">\(N\)</span> with a size of about <span class="math notranslate nohighlight">\(N \sim \tau^2/\epsilon\)</span> for the desired precision <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p>
<p>Since the system we are dealing with here is represented by a small matrix of <span class="math notranslate nohighlight">\(4 \times 4\)</span>, let’s diagonalize <span class="math notranslate nohighlight">\(H_{\textrm{eff}}\)</span> exactly and find its minimum eigenvalue <span class="math notranslate nohighlight">\(E_{\textrm{min}}\)</span>, and compare it with <span class="math notranslate nohighlight">\(\lambda_{\textrm{Trot}}\)</span> of <span class="math notranslate nohighlight">\(e^{i \lambda_{\textrm{Trot}}\tau}\)</span> which is the eigenvalue of <span class="math notranslate nohighlight">\(U_{\textrm{Trot}}^{(N)}\)</span>.</p>
<p>Next, we diagonize <span class="math notranslate nohighlight">\(U_{\textrm{Trot}}^{(N)}\)</span>. Later, we implement <span class="math notranslate nohighlight">\(U_{\textrm{Trot}}^{(N)}\)</span> as a quantum circuit. Here, we calculate it by using the following formula which holds true when <span class="math notranslate nohighlight">\(H_i^2 = I\)</span></p>
<div class="math notranslate nohighlight">
\[\left( \prod_{i=1,2,4,5} \exp[-i g_i H_i \tau/N] \right)^N = \left( \prod_{i=1,2,4,5} \left( \cos(g_i\tau/N) I -i \sin(g_i\tau/N) H_i \right) \right)^N\]</div>
<p>Then, find the <span class="math notranslate nohighlight">\(\lambda_{\textrm{Trot}}\)</span> of the eigenvalue <span class="math notranslate nohighlight">\(e^{-i \lambda_{\textrm{Trot}}\tau}\)</span> of <span class="math notranslate nohighlight">\(U_{\textrm{Trot}}^{(N)}\)</span> at <span class="math notranslate nohighlight">\(N = 1, 3, \ldots, 9\)</span> and compare it with <span class="math notranslate nohighlight">\(E_{\textrm{min}}\)</span>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span>
<span class="k">def</span> <span class="nf">order_n_trotter_approx</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n_trotter_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ordering: &#39;Z0&#39;, &#39;Y0 Y1&#39;, &#39;Z1&#39;, &#39;X0 X1&#39;</span>
<span class="sd">    Returns:</span>
<span class="sd">        args: list of phases of each eigenvalue, exp(i*phase)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">pauli_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">pauli_label</span><span class="p">(</span><span class="s1">&#39;Z0&#39;</span><span class="p">),</span> <span class="n">pauli_label</span><span class="p">(</span><span class="s1">&#39;Y0 Y1&#39;</span><span class="p">),</span> <span class="n">pauli_label</span><span class="p">(</span><span class="s1">&#39;Z1&#39;</span><span class="p">),</span> <span class="n">pauli_label</span><span class="p">(</span><span class="s1">&#39;X0 X1&#39;</span><span class="p">)]</span>
    <span class="n">time_evolution_exponent</span> <span class="o">=</span> <span class="n">reduced_hamiltonian</span> <span class="o">*</span> <span class="n">t</span> <span class="o">/</span> <span class="n">n_trotter_steps</span>

    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_qubits</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">pauli_strings</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">time_evolution_exponent</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="n">get_sparse_matrix</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">@</span> <span class="n">expm</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">exponent</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix_power</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">n_trotter_steps</span><span class="p">)</span>  <span class="c1">## this is U_{trot}^{(N)}</span>

    <span class="n">vals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>  <span class="c1">## e^{i lambda_{trot} }</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="c1">## returns value in [-pi, pi] -&gt; we don&#39;t modify output since we know exact value is around -0.86</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="c1">## we return sorted values</span>

<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.640</span> <span class="c1">## taken from table 1 of paper [1]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N, E_trot, |exact_eig - E_trot|&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">phases</span> <span class="o">=</span> <span class="n">order_n_trotter_approx</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">e_trotter</span> <span class="o">=</span> <span class="n">phases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">tau</span>
    <span class="nb">print</span><span class="p">(</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">e_trotter</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">exact_eigenvalue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">e_trotter</span><span class="p">)</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
N, E_trot, |exact_eig - E_trot|
1, -0.8602638575, 4.847e-04
3, -0.8606950998, 5.347e-05
5, -0.8607293316, 1.924e-05
7, -0.8607387560, 9.814e-06
9, -0.8607426335, 5.936e-06
</pre></div></div>
</div>
</section>
<section id="2.-Decomposition-of-the-control-time-evolution-operator-into-a-set-of-gates-that-can-be-easily-executed-on-a-quantum-computer-and-implementation.">
<h3>2. Decomposition of the control time evolution operator into a set of gates that can be easily executed on a quantum computer and implementation.<a class="headerlink" href="#2.-Decomposition-of-the-control-time-evolution-operator-into-a-set-of-gates-that-can-be-easily-executed-on-a-quantum-computer-and-implementation." title="Link to this heading">¶</a></h3>
<p>To run the controlled time evolution operator <span class="math notranslate nohighlight">\(\Lambda \left( \left( U_{\textrm{Trot}}^{(N)} \right)^{2^k} \right)\)</span> on a quantum computer, we need to decompose this into simple quantum gates. In this example, we need to decompose the following controlled rotation gate included in <span class="math notranslate nohighlight">\(U_{\textrm{Trot}}^{(N)}\)</span>.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Lambda(R_Z(\theta))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Lambda(R_{XX}(\theta))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Lambda(R_{YY}(\theta))\)</span></p></li>
</ul>
<p><span class="math notranslate nohighlight">\(R_Z(\theta) = e^{i\theta/2 Z_x}\)</span> is the <span class="math notranslate nohighlight">\(Z\)</span> direction rotation gate acting on the <span class="math notranslate nohighlight">\(x=0,1\)</span> th qubit, <span class="math notranslate nohighlight">\(R_{XX}(\theta) = e^{i\theta/2 X_0 X_1}, R_{YY}(\theta) = e^{i\theta/2 Y_0 Y_1}\)</span> is also a rotation gate.</p>
<p>First, <span class="math notranslate nohighlight">\(\Lambda(R_Z(\theta))\)</span> is a gate that, when multiplied by control bit <span class="math notranslate nohighlight">\(| c \rangle\)</span> and target bit <span class="math notranslate nohighlight">\(| t \rangle\)</span>, satisfies <span class="math notranslate nohighlight">\((c=0,1)\)</span></p>
<div class="math notranslate nohighlight">
\[\Lambda(R_Z(\theta)) | c \rangle | t \rangle = | c \rangle (R_Z(\theta))^c | t \rangle\]</div>
<p>Note that <span class="math notranslate nohighlight">\(\textrm{CNOT} | c \rangle | t \rangle = | c \rangle X^c | t \rangle\)</span>、 <span class="math notranslate nohighlight">\(XZX = -Z\)</span> holds, the formula can be transformed as follows</p>
<div class="math notranslate nohighlight">
\[\textrm{CNOT} \left(I \otimes R_Z(-\theta/2) \right) \textrm{CNOT} \left(I \otimes R_Z(\theta/2) \right) | c \rangle | t \rangle
= | c \rangle　X^c　R_Z(-\theta/2) X^c R_Z(\theta/2) | t \rangle
= | c \rangle \left(R_Z(\theta)\right)^c | t \rangle\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[\Lambda(R_Z(\theta)) = \textrm{CNOT} \left(I \otimes R_Z(-\theta/2) \right) \textrm{CNOT} \left(I \otimes R_Z(\theta/2) \right)\]</div>
<p>In other words, the controlled rotation gate <span class="math notranslate nohighlight">\(\Lambda(R_Z(\theta))\)</span> could be implemented using the basic gates of the CNOT gate and the <span class="math notranslate nohighlight">\(Z\)</span> rotation gate.</p>
<p>Moreover,</p>
<div class="math notranslate nohighlight">
\[\textrm{CNOT}_{0,1} \left(I_0 \otimes Z_1 \right) \textrm{CNOT}_{0,1} = Z_0 \otimes Z_1\]</div>
<p>Using the above, <span class="math notranslate nohighlight">\(\Lambda(R_{ZZ}(\theta))\)</span> can be realized.</p>
<p>Then, using <span class="math notranslate nohighlight">\(H Z H = X\)</span> or <span class="math notranslate nohighlight">\(SH Z HS^{\dagger} = Y\)</span>, <span class="math notranslate nohighlight">\(\Lambda(R_{XX}(\theta))\)</span>, <span class="math notranslate nohighlight">\(\Lambda(R_{YY}(\theta) )\)</span> can be realized respectively. See also the implementation below for details.</p>
<p>In the code below, in Qulacs, we implement a quantum circuit of time evolution operator <span class="math notranslate nohighlight">\(\Lambda \left( \left( U_{\textrm{Trot}}^{(N)} \right)^{2^k} \right)\)</span> and construct a circuit to run in IQPE. The circuit diagram is as follows.</p>
<img alt="IQPE circuit" src="../_images/IQPE1.png" />
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">quri_parts.circuit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span>

<span class="k">def</span> <span class="nf">psi_register_circuit</span><span class="p">(</span>
    <span class="n">g_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_trotter_step</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumCircuit</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct controlled U^{2^{k-1}} circuit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1">## 2 for system, 1 for ancillary</span>
    <span class="n">a_idx</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">tau</span> <span class="o">/</span> <span class="n">n_trotter_step</span><span class="p">)</span> <span class="o">*</span> <span class="n">g_list</span> <span class="c1">## coefficient for Pauli</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span>

    <span class="c1">## controlled time evolution (Apply controll-e^{-iH*tau} for 2^{k-1} times</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trotter_step</span><span class="p">):</span>
            <span class="c1"># CU(Z0) i.e. controlled exp(i phi[0]*Z_0)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_RZ_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">## note that QURI Parts RZ is defined as RZ(theta) = e^{-i*theta/2*Z}</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_RZ_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># CU(Y0 Y1)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_Sdag_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_Sdag_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_RZ_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_RZ_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_S_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_S_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># CU(Z1)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_RZ_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">phi</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_RZ_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">phi</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># CU(X0 X1)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_RZ_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">phi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_RZ_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">phi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_CNOT_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circuit</span>

<span class="k">def</span> <span class="nf">IQPE_circuit</span><span class="p">(</span>
    <span class="n">g_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">kickback_phase</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_trotter_step</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumCircuit</span><span class="p">:</span>
    <span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1">## 2 for system, 1 for ancillary</span>
    <span class="n">a_idx</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1">## ancilla index</span>

    <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">cbit_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">## Apply Hadamard to ancilla</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">)</span>
    <span class="c1">## Apply kickback phase rotation to ancilla bit</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">add_RZ_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">,</span> <span class="o">-</span><span class="n">kickback_phase</span><span class="p">)</span>
    <span class="c1">## controlled time evolution (Apply controll-e^{-iH*tau} for 2^{k-1} times</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">psi_register_circuit</span><span class="p">(</span><span class="n">g_list</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n_trotter_step</span><span class="p">))</span>
    <span class="c1">## Apply Hadamard to ancilla</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">add_H_gate</span><span class="p">(</span><span class="n">a_idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circuit</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="3.-Prepare-an-initial-state-with-sufficient-overlap-with-the-ground-state">
<h3>3. Prepare an initial state with sufficient overlap with the ground state<a class="headerlink" href="#3.-Prepare-an-initial-state-with-sufficient-overlap-with-the-ground-state" title="Link to this heading">¶</a></h3>
<p>In the explanation of QPE and IQPE so far, for the sake of simplicity, we have assumed that the state on which <span class="math notranslate nohighlight">\(U\)</span> acts is its eigenstate. In fact, even if the input state is “sufficiently close to (overlapping) the state for which the eigenvalue is desired,” the eigenvalue can be obtained with sufficiently high accuracy.</p>
<p>Let <span class="math notranslate nohighlight">\(|n \rangle\)</span> be the eigenstate of the Hamiltonian, E be the corresponding eigenvalue, and p be the reference state.</p>
<div class="math notranslate nohighlight">
\[e^{iH } |0\ldots 0 \rangle  |\phi \rangle \xrightarrow{QPE} \sum_n c_n |\tilde{E_n} \rangle  |n \rangle\]</div>
<p>Here, for example, if the 1st ancillary bit <span class="math notranslate nohighlight">\(j_1\)</span> is measured, the probability of observing 0 is <span class="math notranslate nohighlight">\(\sum_{n \, \textrm{s.t.} \tilde{E_n}^{(1)}=0 } |c_n|^2\)</span> , that is, proportional to the sum of the weights for the eigenvalues ​​<span class="math notranslate nohighlight">\(E_n\)</span> whose first digit in the binary decimal expansion of the eigenvalues ​​is 0. Therefore, if the value of <span class="math notranslate nohighlight">\(\{|c_n|^2\}_n\)</span> is large enough only for the desired state, repeat the measurement of <span class="math notranslate nohighlight">\(j_1\)</span> and take 0 or 1, whichever is more observed,
to obtain the desired eigenvalue of (See also Nielsen-Chuang’s <code class="docutils literal notranslate"><span class="pre">Exercise</span> <span class="pre">5.8</span></code> for a more rigorous treatment.)</p>
<p>In the case of the problem of obtaining the ground energy of the hydrogen molecule this time, the Hartree-Fock (HF) state <span class="math notranslate nohighlight">\(|\phi \rangle = |01 \rangle\)</span> is sufficiently close to the ground state, so it is used (Note: In this case the HF state is <span class="math notranslate nohighlight">\(|01\rangle\)</span>[1])</p>
</section>
<section id="4.-Measure-energy-eigenvalues-​​with-IQPE">
<h3>4. Measure energy eigenvalues ​​with IQPE<a class="headerlink" href="#4.-Measure-energy-eigenvalues-​​with-IQPE" title="Link to this heading">¶</a></h3>
<p>Now let’s run IQPE.</p>
<p>The implementation below uses <code class="docutils literal notranslate"><span class="pre">get_marginal_probability</span></code> function in the <code class="docutils literal notranslate"><span class="pre">quri_parts.qulacs.simulator</span></code> module. This is convenient when measuring only specific qubits such as auxiliary bits and using the results. This is a function that calculates the probability that a particular qubit of a quantum state <code class="docutils literal notranslate"><span class="pre">state</span></code> has a particular bit value from the amplitude of the wave function. For example, the probability that the ancillary bit (<code class="docutils literal notranslate"><span class="pre">index=2</span></code>) is in the <code class="docutils literal notranslate"><span class="pre">0</span></code> state is obtained with
<code class="docutils literal notranslate"><span class="pre">get_marginal_probability(state:</span> <span class="pre">{2:</span> <span class="pre">0})</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">quri_parts.core.state</span> <span class="kn">import</span> <span class="n">GeneralCircuitQuantumState</span>
<span class="kn">from</span> <span class="nn">quri_parts.qulacs.simulator</span> <span class="kn">import</span> <span class="n">evaluate_state_to_vector</span><span class="p">,</span> <span class="n">get_marginal_probability</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">def</span> <span class="nf">iterative_phase_estimation</span><span class="p">(</span>
    <span class="n">g_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n_itter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">init_state</span><span class="p">:</span> <span class="n">GeneralCircuitQuantumState</span><span class="p">,</span>
    <span class="n">n_trotter_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">kickback_phase</span><span class="o">=</span><span class="mf">0.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_itter</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span> <span class="c1">## run from n_itter to 1</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">IQPE_circuit</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_list</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">,</span>
            <span class="n">tau</span><span class="p">,</span>
            <span class="n">kickback_phase</span><span class="p">,</span>
            <span class="n">k</span><span class="p">,</span>
            <span class="n">n_trotter_step</span><span class="o">=</span><span class="n">n_trotter_step</span>
        <span class="p">)</span>

        <span class="c1">## execute circuit</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">evaluate_state_to_vector</span><span class="p">(</span>
            <span class="n">init_state</span><span class="o">.</span><span class="n">with_gates_applied</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">vector</span>

        <span class="c1"># partial trace</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">get_marginal_probability</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">get_marginal_probability</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
        <span class="c1"># print(f&quot;    k={k:2d}, p0={p0:.3f}, p1={p1:.3f}&quot;)</span>

        <span class="c1"># update kickback phase</span>
        <span class="n">kth_digit</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">p0</span> <span class="o">&lt;</span> <span class="n">p1</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">kickback_phase</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">kickback_phase</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">kth_digit</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">kickback_phase</span>
</pre></div>
</div>
</div>
<p>Then, IQPE is executed while checking how many digits the phase should be measured (how large <span class="math notranslate nohighlight">\(t\)</span> of <span class="math notranslate nohighlight">\(0.j_1 \ldots j_t\)</span> should be). When chemical precision (<span class="math notranslate nohighlight">\(1.6 \times 10^{-3}\)</span> Ha), which is one measure of precision in chemistry calculation, is required, the number of iterations theoretically estimated [3] is</p>
<div class="math notranslate nohighlight">
\[t = - \log_2 (1.6 \times 10^{-3}) + \log_2 \left(2 + \frac{1}{2 \times 0.5} \right) \approx 10.87\]</div>
<p>In other words, <span class="math notranslate nohighlight">\(t = 11\)</span> is sufficient. Let’s actually calculate it.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">quri_parts.core.state</span> <span class="kn">import</span> <span class="n">ComputationalBasisState</span>
<span class="n">n_elec_conf_qubit</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">n_ancilla</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="n">n_elec_conf_qubit</span> <span class="o">+</span> <span class="n">n_ancilla</span>

<span class="n">g_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">reduced_hamiltonian</span><span class="p">[</span><span class="n">pauli_label</span><span class="p">(</span><span class="s2">&quot;Z0&quot;</span><span class="p">)],</span>
    <span class="n">reduced_hamiltonian</span><span class="p">[</span><span class="n">pauli_label</span><span class="p">(</span><span class="s2">&quot;Y0 Y1&quot;</span><span class="p">)],</span>
    <span class="n">reduced_hamiltonian</span><span class="p">[</span><span class="n">pauli_label</span><span class="p">(</span><span class="s2">&quot;Z1&quot;</span><span class="p">)],</span>
    <span class="n">reduced_hamiltonian</span><span class="p">[</span><span class="n">pauli_label</span><span class="p">(</span><span class="s2">&quot;Y0 Y1&quot;</span><span class="p">)],</span>
<span class="p">]</span>

<span class="n">hf_state</span> <span class="o">=</span> <span class="n">bk_state_mapper</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.640</span>

<span class="n">e_trotter</span> <span class="o">=</span> <span class="n">order_n_trotter_approx</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">n_trotter_steps</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">tau</span> <span class="c1">## exact one of U_{Trot}^{(N)}</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;e_trotter=</span><span class="si">{</span><span class="n">e_trotter</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">result_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n_itter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># precission in digit</span>
    <span class="n">iqpe_phase</span> <span class="o">=</span> <span class="n">iterative_phase_estimation</span><span class="p">(</span><span class="n">g_list</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">n_itter</span><span class="p">,</span> <span class="n">hf_state</span><span class="p">,</span> <span class="n">n_trotter_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kickback_phase</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">e_iqpe</span> <span class="o">=</span> <span class="o">-</span> <span class="n">iqpe_phase</span><span class="o">/</span><span class="n">tau</span> <span class="c1">## U=exp(-iH*tau) so the IQPE picks up eigenvalue of -H*tau</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_itter=</span><span class="si">{</span><span class="n">n_itter</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">, e_iqpe=</span><span class="si">{</span><span class="n">e_iqpe</span><span class="si">:</span><span class="s2">10f</span><span class="si">}</span><span class="s2">, error=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e_iqpe</span><span class="o">-</span><span class="n">e_trotter</span><span class="p">)</span><span class="si">:</span><span class="s2">.5e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">result_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n_itter</span><span class="p">,</span> <span class="n">e_iqpe</span><span class="p">])</span>

<span class="c1">#print(&#39;e_iqpe = {} Ha, |e_iqpe-e_trotter| = {} Ha&#39;.format(e_iqpe, abs(e_iqpe-e_trotter)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
e_trotter=-0.8602638575
n_itter= 1, e_iqpe= -0.000000, error=8.60264e-01
n_itter= 2, e_iqpe= -0.000000, error=8.60264e-01
n_itter= 3, e_iqpe= -1.227185, error=3.66921e-01
n_itter= 4, e_iqpe= -0.613592, error=2.46672e-01
n_itter= 5, e_iqpe= -0.920388, error=6.01246e-02
n_itter= 6, e_iqpe= -0.920388, error=6.01246e-02
n_itter= 7, e_iqpe= -0.843689, error=1.65744e-02
n_itter= 8, e_iqpe= -0.843689, error=1.65744e-02
n_itter= 9, e_iqpe= -0.862864, error=2.60034e-03
n_itter=10, e_iqpe= -0.862864, error=2.60034e-03
n_itter=11, e_iqpe= -0.858071, error=2.19335e-03
n_itter=12, e_iqpe= -0.860467, error=2.03491e-04
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1">## plotting the result</span>
<span class="n">result_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result_list</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;# of digit&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">result_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">result_array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e_trotter</span><span class="p">),</span> <span class="s2">&quot;bo-&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">13</span><span class="p">],</span> <span class="mf">1.6e-3</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;lightgrey&quot;</span><span class="p">)</span> <span class="c1">## fill the chemical accuracy region</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;matplotlib.collections.PolyCollection at 0x29b4472e0&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/qp_notebooks_7.1_qp_quantum_phase_estimation_detailed_26_1.png" src="../_images/qp_notebooks_7.1_qp_quantum_phase_estimation_detailed_26_1.png" />
</div>
</div>
<p>As expected, we finally reached chemical accuracy at <code class="docutils literal notranslate"><span class="pre">n_itter</span> <span class="pre">=</span> <span class="pre">12</span></code>.</p>
<p>One thing to note here is that the sample code introduced here uses the (controlled) time evolution operator <span class="math notranslate nohighlight">\(\Lambda \left( \left( U_{\textrm{Trot}}^{(N)} \right)^{2^k} \right)\)</span> whose depth grows exponentially with respect to <span class="math notranslate nohighlight">\(t\)</span>. That is, exponentially more gates must be used to improve accuracy. Here, we introduced a method based on a simple Trotter decomposition, there have been many studies using other methods to efficiently implement the time evolution operator. Interested
readers are referred to references [4][5][6].</p>
</section>
<section id="5.-Iterative-Phase-estimation-with-QURI-Parts-Sampler">
<h3>5. Iterative Phase estimation with QURI Parts Sampler<a class="headerlink" href="#5.-Iterative-Phase-estimation-with-QURI-Parts-Sampler" title="Link to this heading">¶</a></h3>
<p>The above implementation uses a simulator that evaluates the probability of the measurement outcome deterministically. However, this is not possible on real devices. Thus, we slightly change the function to use a sampler instead of a simulator. For each number of iterations, we repeat the algorithm 100 times and pick the phase the shows up with the most number of times as the estimated phase.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">quri_parts.qulacs.sampler</span> <span class="kn">import</span> <span class="n">create_qulacs_vector_sampler</span>
<span class="kn">from</span> <span class="nn">quri_parts.core.sampling</span> <span class="kn">import</span> <span class="n">Sampler</span>


<span class="n">sampler</span> <span class="o">=</span> <span class="n">create_qulacs_vector_sampler</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">iterative_phase_estimation_sampler</span><span class="p">(</span>
    <span class="n">g_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n_itter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">init_state</span><span class="p">:</span> <span class="n">GeneralCircuitQuantumState</span><span class="p">,</span>
    <span class="n">n_trotter_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">kickback_phase</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">sampler</span><span class="p">:</span> <span class="n">Sampler</span><span class="o">=</span><span class="n">sampler</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_itter</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span> <span class="c1">## run from n_itter to 1</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">IQPE_circuit</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_list</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">,</span>
            <span class="n">tau</span><span class="p">,</span>
            <span class="n">kickback_phase</span><span class="p">,</span>
            <span class="n">k</span><span class="p">,</span>
            <span class="n">n_trotter_step</span><span class="o">=</span><span class="n">n_trotter_step</span>
        <span class="p">)</span>

        <span class="c1">## execute circuit</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">init_state</span><span class="o">.</span><span class="n">with_gates_applied</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
        <span class="n">kth_digit</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">sampler</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">circuit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span>

        <span class="c1"># update kickback phase</span>
        <span class="n">kickback_phase</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">kickback_phase</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">kth_digit</span>

    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">kickback_phase</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="n">n_elec_conf_qubit</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">n_ancilla</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="n">n_elec_conf_qubit</span> <span class="o">+</span> <span class="n">n_ancilla</span>

<span class="n">g_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">reduced_hamiltonian</span><span class="p">[</span><span class="n">pauli_label</span><span class="p">(</span><span class="s2">&quot;Z0&quot;</span><span class="p">)],</span>
    <span class="n">reduced_hamiltonian</span><span class="p">[</span><span class="n">pauli_label</span><span class="p">(</span><span class="s2">&quot;Y0 Y1&quot;</span><span class="p">)],</span>
    <span class="n">reduced_hamiltonian</span><span class="p">[</span><span class="n">pauli_label</span><span class="p">(</span><span class="s2">&quot;Z1&quot;</span><span class="p">)],</span>
    <span class="n">reduced_hamiltonian</span><span class="p">[</span><span class="n">pauli_label</span><span class="p">(</span><span class="s2">&quot;Y0 Y1&quot;</span><span class="p">)],</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">run_qpe_with_sampler</span><span class="p">(</span><span class="n">n_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">repeat</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">hf_state</span> <span class="o">=</span> <span class="n">bk_state_mapper</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="mf">0.640</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repeat</span><span class="p">):</span>
        <span class="n">iqpe_phase</span> <span class="o">=</span> <span class="n">iterative_phase_estimation_sampler</span><span class="p">(</span><span class="n">g_list</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span> <span class="n">hf_state</span><span class="p">,</span> <span class="n">n_trotter_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kickback_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="o">-</span> <span class="n">iqpe_phase</span><span class="o">/</span><span class="n">tau</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

    <span class="n">times</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">phase</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">times</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">phase</span>

    <span class="k">return</span> <span class="n">best</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sampler_result_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># precission in digit</span>
    <span class="n">e_iqpe</span> <span class="o">=</span> <span class="n">run_qpe_with_sampler</span><span class="p">(</span><span class="n">n_iter</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_itter=</span><span class="si">{</span><span class="n">n_iter</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">, e_iqpe=</span><span class="si">{</span><span class="n">e_iqpe</span><span class="si">:</span><span class="s2">10f</span><span class="si">}</span><span class="s2">, error=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e_iqpe</span><span class="o">-</span><span class="n">e_trotter</span><span class="p">)</span><span class="si">:</span><span class="s2">.5e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">sampler_result_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">e_iqpe</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
n_itter= 1, e_iqpe= -0.000000, error=8.60264e-01
n_itter= 2, e_iqpe= -0.000000, error=8.60264e-01
n_itter= 3, e_iqpe= -1.227185, error=3.66921e-01
n_itter= 4, e_iqpe= -0.613592, error=2.46672e-01
n_itter= 5, e_iqpe= -0.920388, error=6.01246e-02
n_itter= 6, e_iqpe= -0.920388, error=6.01246e-02
n_itter= 7, e_iqpe= -0.843689, error=1.65744e-02
n_itter= 8, e_iqpe= -0.843689, error=1.65744e-02
n_itter= 9, e_iqpe= -0.862864, error=2.60033e-03
n_itter=10, e_iqpe= -0.862864, error=2.60033e-03
n_itter=11, e_iqpe= -0.858070, error=2.19336e-03
n_itter=12, e_iqpe= -0.860467, error=2.03493e-04
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1">## plotting the result</span>
<span class="n">result_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sampler_result_list</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;# of digit&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">result_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">result_array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e_trotter</span><span class="p">),</span> <span class="s2">&quot;bo-&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">13</span><span class="p">],</span> <span class="mf">1.6e-3</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;lightgrey&quot;</span><span class="p">)</span> <span class="c1">## fill the chemical accuracy region</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;matplotlib.collections.PolyCollection at 0x29b319490&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/qp_notebooks_7.1_qp_quantum_phase_estimation_detailed_32_1.png" src="../_images/qp_notebooks_7.1_qp_quantum_phase_estimation_detailed_32_1.png" />
</div>
</div>
</section>
</section>
<section id="Reference">
<h2>Reference<a class="headerlink" href="#Reference" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line">[1] P. J. J. O’Malley <em>et al.</em> , “Scalable Quantum Simulation of Molecular Energies“, <a class="reference external" href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.031007">PHYSICAL REVIEW X 6, 031007 (2016)</a></div>
<div class="line">[2] S. Lloyd, “Universal Quantum Simulators“, <a class="reference external" href="https://science.sciencemag.org/content/273/5278/1073">Science 273, Issue 5278, pp.1073-1078</a></div>
<div class="line">[3] M. Nielsen and I. Chuang, “Quantum Computation and Quantum Information“ , Sec. 5.2</div>
<div class="line">[4] D. W. Berry, G. Ahokas, R. Cleve, B. C. Sanders, “Efficient quantum algorithms for simulating sparse Hamiltonians“, <a class="reference external" href="https://link.springer.com/article/10.1007/s00220-006-0150-x">Communications in Mathematical Physics 270, 359 (2007)</a></div>
<div class="line">[5] D. W. Berry and A. M. Childs, “Black-box Hamiltonian simulation and unitary implementation“, <a class="reference external" href="http://www.rintonpress.com/journals/qiconline.html#v12n12">Quantum Information and Computation 12, 29 (2012)</a></div>
<div class="line">[6] D. W. Berry, A. M. Childs, R. Cleve, R. Kothari, and R. D. Somma, “Simulating Hamiltonian dynamics with a truncated Taylor series“, <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevLett.114.090502">Phys. Rev. Lett. 114, 090502 (2015)</a></div>
</div>
</section>
</section>

</article>
        <aside class="nftt-toc">
          
          <div class="mt-3 mb-1 my-lg-0 ps-xl-3 text-muted">
            <button class="btn btn-link link-dark p-lg-0 mb-2 mb-lg-0 text-decoration-none nftt-toc-toggle d-lg-none" type="button" data-bs-toggle="collapse" data-bs-target="#tocContents" aria-expanded="false" aria-controls="tocContents"
            >On this page <i class="ms-2 bi bi-chevron-expand"></i></button>
            <div class="title d-none d-lg-block">
              <i class="bi bi-file-earmark-text"></i>&nbsp;&nbsp;<span class="small">On this page</span>
            </div>
            <div class="collapse nftt-toc-collapse" id="tocContents">
              <nav id="TableOfContents">
                <ul>
<li><a class="reference internal" href="#">7-1. Quantum Phase Estimation Algorithm in Detail: Application to Hydrogen Molecule as an Example</a><ul>
<li><a class="reference internal" href="#Review-of-Phase-Estimation">Review of Phase Estimation</a></li>
<li><a class="reference internal" href="#Iterative-Quantum-Phase-Estimation">Iterative Quantum Phase Estimation</a><ul>
<li><a class="reference internal" href="#k-=-t"><span class="math notranslate nohighlight">\(k = t\)</span></a></li>
<li><a class="reference internal" href="#k-=-t-1,-t-2,-\ldots,-1"><span class="math notranslate nohighlight">\(k = t-1, t-2, \ldots, 1\)</span></a></li>
<li><a class="reference internal" href="#After-measuring-all-j_k-(k-=-t,-t-1,-\ldots,-1)">After measuring all <span class="math notranslate nohighlight">\(j_k\)</span> (<span class="math notranslate nohighlight">\(k = t, t-1, \ldots, 1\)</span>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#Example:-Calculation-of-the-ground-state-energy-of-the-hydrogen-molecular-Hamiltonian-using-the-quantum-phase-estimation-algorithm">Example: Calculation of the ground state energy of the hydrogen molecular Hamiltonian using the quantum phase estimation algorithm</a><ul>
<li><a class="reference internal" href="#0.-(Reduce-Hamiltonian-size-using-symmetry-etc.)">0. (Reduce Hamiltonian size using symmetry etc.)</a></li>
<li><a class="reference internal" href="#1.-Accurate-approximation-of-Hamiltonian-time-evolution-operator-U=e^{-iH\tau}">1. Accurate approximation of Hamiltonian time evolution operator <span class="math notranslate nohighlight">\(U=e^{-iH\tau}\)</span></a></li>
<li><a class="reference internal" href="#2.-Decomposition-of-the-control-time-evolution-operator-into-a-set-of-gates-that-can-be-easily-executed-on-a-quantum-computer-and-implementation.">2. Decomposition of the control time evolution operator into a set of gates that can be easily executed on a quantum computer and implementation.</a></li>
<li><a class="reference internal" href="#3.-Prepare-an-initial-state-with-sufficient-overlap-with-the-ground-state">3. Prepare an initial state with sufficient overlap with the ground state</a></li>
<li><a class="reference internal" href="#4.-Measure-energy-eigenvalues-​​with-IQPE">4. Measure energy eigenvalues ​​with IQPE</a></li>
<li><a class="reference internal" href="#5.-Iterative-Phase-estimation-with-QURI-Parts-Sampler">5. Iterative Phase estimation with QURI Parts Sampler</a></li>
</ul>
</li>
<li><a class="reference internal" href="#Reference">Reference</a></li>
</ul>
</li>
</ul>

              </nav>
            </div>
          </div>
          
        </aside>
      </div>
    </div>

    <footer class="nftt-footer">
      
<nav id="paginator"></nav>

      <div class="py-5 px-4 px-md-3">
  <div class="container">
    

    <div class="row">
      <div class="col-lg-12 text-center">
        <a class="brand-text d-inline-flex align-items-center mb-2 text-decoration-none" href="/" aria-label="Nefertiti-for-Sphinx">
          <span class="fs-6 fw-bold">Quantum Native Dojo</span>
        </a>
        
          <ul class="list-unstyled small text-muted">
            <li>2023, Quantum Native Dojo Contributors</li>
          </ul>
        
        
        <div class="built-with pt-2">
          Built with <a href="http://sphinx-doc.org">Sphinx 7.2.6</a> and <a href="https://github.com/danirus/sphinx-nefertiti">Nefertiti 0.3.0</a>
        </div>
        
      </div>
    </div>
  </div>
</div>
    </footer>
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"CommonHTML": {"undefinedFamily": "\"Source Serif Pro\", \"Yakumono\", \"Noto Serif JP\", \"Hiragino Mincho ProN\", \"STIXGeneral\", \"Arial Unicode MS\", serif"}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script>

    <script type="text/javascript" src="../_static/bootstrap.bundle.min.js"></script>
    <script type="text/javascript" src="../_static/sphinx-nefertiti.min.js"></script>
    
    <script type="text/javascript" src="../_static/doc_versions.js"></script>
  </body>
</html>